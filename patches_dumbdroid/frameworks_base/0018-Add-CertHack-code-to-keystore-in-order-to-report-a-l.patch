From 865c236fa06fa42ea915c5ae622d6f21eafe7ee2 Mon Sep 17 00:00:00 2001
From: Michal Brzozowski <miki@extremic.com>
Date: Sat, 16 Aug 2025 09:03:22 +0200
Subject: [PATCH 18/46] Add CertHack code to keystore in order to report a
 locked bootloader

Change-Id: I9bf196aaf8598f40e3743dd02ec66b88e1db45fc
---
 Android.bp                                    |   16 +
 .../security/KeyStoreSecurityLevel.java       |  112 +-
 .../keystore2/AndroidKeyStoreSpi.java         |   20 +-
 .../android/security/keystore2/CertHack.java  |  813 ++++++++++++
 .../android/security/keystore2/Logger.java    |   31 +
 .../android/security/keystore2/UtilKt.java    |  231 ++++
 .../android/security/keystore2/Utils.java     |   94 ++
 .../android/security/keystore2/XMLParser.java |  111 ++
 .../security/keystore2/XmlPullParser.java     | 1150 +++++++++++++++++
 .../keystore2/XmlPullParserException.java     |   97 ++
 .../keystore2/XmlPullParserFactory.java       |  254 ++++
 .../security/keystore2/XmlSerializer.java     |  329 +++++
 12 files changed, 3256 insertions(+), 2 deletions(-)
 create mode 100644 keystore/java/android/security/keystore2/CertHack.java
 create mode 100644 keystore/java/android/security/keystore2/Logger.java
 create mode 100644 keystore/java/android/security/keystore2/UtilKt.java
 create mode 100644 keystore/java/android/security/keystore2/Utils.java
 create mode 100644 keystore/java/android/security/keystore2/XMLParser.java
 create mode 100644 keystore/java/android/security/keystore2/XmlPullParser.java
 create mode 100644 keystore/java/android/security/keystore2/XmlPullParserException.java
 create mode 100644 keystore/java/android/security/keystore2/XmlPullParserFactory.java
 create mode 100644 keystore/java/android/security/keystore2/XmlSerializer.java

diff --git a/Android.bp b/Android.bp
index b8a44b325130..2063d1f79987 100644
--- a/Android.bp
+++ b/Android.bp
@@ -450,6 +450,9 @@ java_defaults {
     libs: [
         "framework-virtualization.stubs.module_lib",
         "framework-non-updatable-unbundled-impl-libs",
+        "bouncycastle_asn1",
+        "bouncycastle_pkix",
+        "bouncycastle_util",
     ],
 }
 
@@ -484,6 +487,11 @@ java_library {
     ],
     compile_dex: false,
     headers_only: true,
+    static_libs: [
+        "bouncycastle_asn1",
+        "bouncycastle_pkix",
+        "bouncycastle_util",
+    ],
 }
 
 java_library {
@@ -505,6 +513,11 @@ java_library {
         "//frameworks/base/packages/Tethering/tests/unit",
         "//packages/modules/Connectivity/Tethering/tests/unit",
     ],
+    static_libs: [
+        "bouncycastle_asn1",
+        "bouncycastle_pkix",
+        "bouncycastle_util",
+    ],
     errorprone: {
         javacflags: [
             "-Xep:AndroidFrameworkCompatChange:ERROR",
@@ -551,6 +564,9 @@ java_library {
         "framework-minus-apex",
         "framework-non-updatable-unbundled-impl-libs",
         "framework-updatable-stubs-module_libs_api",
+        "bouncycastle_asn1",
+        "bouncycastle_pkix",
+        "bouncycastle_util",
     ],
     sdk_version: "core_platform",
     apex_available: ["//apex_available:platform"],
diff --git a/keystore/java/android/security/KeyStoreSecurityLevel.java b/keystore/java/android/security/KeyStoreSecurityLevel.java
index 6ab148a8b4ea..c8e404bce234 100644
--- a/keystore/java/android/security/KeyStoreSecurityLevel.java
+++ b/keystore/java/android/security/KeyStoreSecurityLevel.java
@@ -31,10 +31,22 @@ import android.system.keystore2.IKeystoreSecurityLevel;
 import android.system.keystore2.KeyDescriptor;
 import android.system.keystore2.KeyMetadata;
 import android.system.keystore2.ResponseCode;
+import android.system.keystore2.KeyEntryResponse;
+import android.security.keystore2.CertHack;
+import android.security.keystore2.Utils;
 import android.util.Log;
-
+import java.security.cert.Certificate;
+import android.system.keystore2.Authorization;
+import android.hardware.security.keymint.Tag;
+import android.hardware.security.keymint.KeyParameterValue;
+import android.hardware.security.keymint.SecurityLevel;
 import java.util.Calendar;
 import java.util.Collection;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.ArrayList;
+import android.util.Pair;
+import java.security.KeyPair;
 
 /**
  * This is a shim around the security level specific interface of Keystore 2.0. Services with
@@ -141,11 +153,109 @@ public class KeyStoreSecurityLevel {
      * @throws KeyStoreException
      * @hide
      */
+    private static CertHack.KeyGenParameters toKeyGenParameters(Collection<KeyParameter> args) {
+        KeyParameter[] array = args.toArray(new KeyParameter[0]);
+        return new CertHack.KeyGenParameters(array);
+    }
+
+    private static boolean hasAttestationChallenge(CertHack.KeyGenParameters kgp) {
+        return kgp.attestationChallenge != null;
+    }
+
+    private KeyEntryResponse buildResponse(
+            List<Certificate> chain, CertHack.KeyGenParameters params, KeyDescriptor descriptor, IKeystoreSecurityLevel originalSecurityLevel) {
+
+        KeyEntryResponse response = new KeyEntryResponse();
+        KeyMetadata metadata = new KeyMetadata();
+        try {
+        Utils.putCertificateChain(metadata, chain.toArray(new Certificate[0]));
+        } catch (Throwable t) {
+            Log.e("Dumbdroid", "putCertificateChain", t);
+        }
+
+        KeyDescriptor d = new KeyDescriptor();
+        d.domain = descriptor.domain;
+        d.nspace = descriptor.nspace;
+        metadata.key = d;
+
+        ArrayList<Authorization> authorizations = new ArrayList<>();
+        Authorization a;
+
+        for (int purpose : params.purpose) {
+            a = new Authorization();
+            a.keyParameter = new KeyParameter();
+            a.keyParameter.tag = Tag.PURPOSE;
+            a.keyParameter.value = KeyParameterValue.keyPurpose(purpose);
+            a.securityLevel = SecurityLevel.TRUSTED_ENVIRONMENT;
+            authorizations.add(a);
+        }
+        for (int digest : params.digest) {
+            a = new Authorization();
+            a.keyParameter = new KeyParameter();
+            a.keyParameter.tag = Tag.DIGEST;
+            a.keyParameter.value = KeyParameterValue.digest(digest);
+            a.securityLevel = SecurityLevel.TRUSTED_ENVIRONMENT;
+            authorizations.add(a);
+        }
+        // algorithm
+        a = new Authorization();
+        a.keyParameter = new KeyParameter();
+        a.keyParameter.tag = Tag.ALGORITHM;
+        a.keyParameter.value = KeyParameterValue.algorithm(params.algorithm);
+        a.securityLevel = SecurityLevel.TRUSTED_ENVIRONMENT;
+        authorizations.add(a);
+        // key size
+        a = new Authorization();
+        a.keyParameter = new KeyParameter();
+        a.keyParameter.tag = Tag.KEY_SIZE;
+        a.keyParameter.value = KeyParameterValue.integer(params.keySize);
+        a.securityLevel = SecurityLevel.TRUSTED_ENVIRONMENT;
+        authorizations.add(a);
+        // no auth required, etc. (mirror what TrickyStore does)
+        a = new Authorization();
+        a.keyParameter = new KeyParameter();
+        a.keyParameter.tag = Tag.NO_AUTH_REQUIRED;
+        a.keyParameter.value = KeyParameterValue.boolValue(true);
+        a.securityLevel = SecurityLevel.TRUSTED_ENVIRONMENT;
+        authorizations.add(a);
+
+        metadata.authorizations = authorizations.toArray(Authorization[]::new);
+        response.metadata = metadata;
+        response.iSecurityLevel = originalSecurityLevel; // set appropriately if needed
+        return response;
+    }
+
     public KeyMetadata generateKey(@NonNull KeyDescriptor descriptor, KeyDescriptor attestationKey,
             Collection<KeyParameter> args, int flags, byte[] entropy)
             throws KeyStoreException {
         StrictMode.noteDiskWrite();
+        Log.i("Dumbdroid", "generateKey");
+        CertHack.KeyGenParameters kgp = toKeyGenParameters(args);
+
+        // Only intercept if there's an attestation challenge and we're not delegating to a separate attestation key
+        if (hasAttestationChallenge(kgp) && attestationKey == null) {
+            Log.i("Dumbdroid", "generateKey hacking");
+            int callingUid = Binder.getCallingUid(); // or appropriate UID source in this context
+            try {
+                Log.i("Dumbdroid", "generateKey hacking2");
+                Pair<KeyPair, List<Certificate>> pair = CertHack.generateKeyPair(callingUid, descriptor, kgp);
+                Log.i("Dumbdroid", "generateKey hacking3");
+                if (pair != null) {
+                    // Build a KeyEntryResponse-equivalent and extract KeyMetadata
+                    KeyEntryResponse response = buildResponse(pair.second, kgp, descriptor, /* original security level */ null);
+                    // Cache it if the surrounding infrastructure expects it (similar to TrickyStore's map)
+                    // Return metadata directly
+                    Log.i("Dumbdroid", "generateKey success");
+                    CertHack.hackedKeys.put(new CertHack.HackedKey(callingUid, descriptor.alias), new CertHack.HackedValue(pair.first, response));
+                    return response.metadata;
+                }
+            } catch (Exception e) {
+                // fallback to normal flow if something fails
+                Log.e("Dumbdroid", "CertHack keypair generation failed, falling back", e);
+            }
+        }
 
+        Log.e("Dumbdroid", "regular generateKey");
         return handleExceptions(() -> mSecurityLevel.generateKey(
                 descriptor, attestationKey, args.toArray(new KeyParameter[args.size()]),
                 flags, entropy));
diff --git a/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java b/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
index e6a63b9c4c17..1da0a5845399 100644
--- a/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
+++ b/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
@@ -178,6 +178,23 @@ public class AndroidKeyStoreSpi extends KeyStoreSpi {
 
     @Override
     public Certificate[] engineGetCertificateChain(String alias) {
+        int callingUid = android.os.Binder.getCallingUid(); // get the UID of the caller
+
+        // First: check if we have a pre-generated / hacked response cached
+        CertHack.HackedKey hackedKey = new CertHack.HackedKey(callingUid, alias);
+        CertHack.HackedValue hackedValue = CertHack.hackedKeys.get(hackedKey); // adjust access if static vs instance
+        Log.w("Dumbdroid", "Will try using cached chain");
+        if (hackedValue != null && hackedValue.response() != null) {
+            // Directly return the chain from the cached response
+            Certificate[] cachedChain = Utils.getCertificateChain(hackedValue.response());
+            Log.w("Dumbdroid", "Will try using cached chain2");
+            if (cachedChain != null) {
+                Log.w("Dumbdroid", "Will try using cached chain: SUCCESS");
+                return cachedChain;
+            }
+            Log.w("Dumbdroid", "Will try using cached chain: FAIL");
+            // fallthrough if something is unexpectedly null
+        }
         KeyEntryResponse response = getKeyMetadata(alias);
 
         if (response == null || response.metadata.certificate == null) {
@@ -208,7 +225,8 @@ public class AndroidKeyStoreSpi extends KeyStoreSpi {
         }
 
         caList[0] = leaf;
-
+	if (CertHack.canHack())
+            return CertHack.hackCertificateChain(caList);
         return caList;
     }
 
diff --git a/keystore/java/android/security/keystore2/CertHack.java b/keystore/java/android/security/keystore2/CertHack.java
new file mode 100644
index 000000000000..7d88e9df58cd
--- /dev/null
+++ b/keystore/java/android/security/keystore2/CertHack.java
@@ -0,0 +1,813 @@
+package android.security.keystore2;
+
+import android.content.pm.PackageManager;
+import android.hardware.security.keymint.Algorithm;
+import android.hardware.security.keymint.EcCurve;
+import android.hardware.security.keymint.KeyParameter;
+import android.hardware.security.keymint.KeyParameterValue;
+import android.hardware.security.keymint.Tag;
+import android.security.keystore.KeyProperties;
+import android.system.keystore2.KeyDescriptor;
+import android.util.Pair;
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.content.pm.PackageInfo;
+import android.os.RemoteException;
+import androidx.annotation.Nullable;
+import android.system.keystore2.KeyEntryResponse;
+
+
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1Boolean;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1Encodable;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1EncodableVector;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1Enumerated;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1Integer;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1OctetString;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1Sequence;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.ASN1TaggedObject;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.DERNull;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.DEROctetString;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.DERSequence;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.DERSet;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.DERTaggedObject;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.x500.X500Name;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.x509.Extension;
+import android.security.keystore2.shaded.org.bouncycastle.asn1.x509.KeyUsage;
+import android.security.keystore2.shaded.org.bouncycastle.cert.X509CertificateHolder;
+import android.security.keystore2.shaded.org.bouncycastle.cert.X509v3CertificateBuilder;
+import android.security.keystore2.shaded.org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
+import android.security.keystore2.shaded.org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;
+import android.security.keystore2.shaded.org.bouncycastle.jce.provider.BouncyCastleProvider;
+import android.security.keystore2.shaded.org.bouncycastle.openssl.PEMKeyPair;
+import android.security.keystore2.shaded.org.bouncycastle.openssl.PEMParser;
+import android.security.keystore2.shaded.org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
+import android.security.keystore2.shaded.org.bouncycastle.operator.ContentSigner;
+import android.security.keystore2.shaded.org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
+import android.security.keystore2.shaded.org.bouncycastle.util.io.pem.PemReader;
+import java.util.concurrent.ConcurrentHashMap;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.StringReader;
+import java.math.BigInteger;
+import java.nio.charset.StandardCharsets;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.MessageDigest;
+import java.security.Security;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateFactory;
+import java.security.cert.CertificateParsingException;
+import java.security.cert.X509Certificate;
+import java.security.spec.ECGenParameterSpec;
+import java.security.spec.RSAKeyGenParameterSpec;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import javax.security.auth.x500.X500Principal;
+import android.annotation.FlaggedApi;
+
+//@FlaggedApi("")
+@SuppressWarnings("MissingNullability")
+/**
+ * @hide
+ */
+public final class CertHack {
+    private CertHack() {}
+    private static final ASN1ObjectIdentifier OID = new ASN1ObjectIdentifier("1.3.6.1.4.1.11129.2.1.17");
+
+    private static final int ATTESTATION_APPLICATION_ID_PACKAGE_INFOS_INDEX = 0;
+    private static final int ATTESTATION_APPLICATION_ID_SIGNATURE_DIGESTS_INDEX = 1;
+    private static final int ATTESTATION_PACKAGE_INFO_PACKAGE_NAME_INDEX = 0;
+
+    private static final CertificateFactory certificateFactory;
+
+    static {
+        try {
+            certificateFactory = CertificateFactory.getInstance("X.509");
+        } catch (Throwable t) {
+            Logger.e("", t);
+            throw new RuntimeException(t);
+        }
+    }
+    private static final int ATTESTATION_PACKAGE_INFO_VERSION_INDEX = 1;
+
+    static boolean canHack() {
+        return !keyboxes.isEmpty();
+    }
+
+    private static PEMKeyPair parseKeyPair(String key) throws Throwable {
+        try (PEMParser parser = new PEMParser(new StringReader(UtilKt.trimLine(key)))) {
+            return (PEMKeyPair) parser.readObject();
+        }
+    }
+
+    private static Certificate parseCert(String cert) throws Throwable {
+        try (PemReader reader = new PemReader(new StringReader(UtilKt.trimLine(cert)))) {
+            return certificateFactory.generateCertificate(new ByteArrayInputStream(reader.readPemObject().getContent()));
+        }
+    }
+
+    private static byte[] getByteArrayFromAsn1(ASN1Encodable asn1Encodable) throws CertificateParsingException {
+        if (!(asn1Encodable instanceof DEROctetString derOctectString)) {
+            throw new CertificateParsingException("Expected DEROctetString");
+        }
+        return derOctectString.getOctets();
+    }
+
+    record KeyBox(PEMKeyPair pemKeyPair, KeyPair keyPair, List<Certificate> certificates) {
+    }
+
+    static Map<String, KeyBox> readFromXml(String data) {
+        Map<String, KeyBox> keyboxes = new HashMap<>();
+        if (data == null) {
+            Logger.i("clear all keyboxes");
+            return null;
+        }
+        XMLParser xmlParser = new XMLParser(data);
+
+        try {
+            int numberOfKeyboxes = Integer.parseInt(Objects.requireNonNull(xmlParser.obtainPath(
+                    "AndroidAttestation.NumberOfKeyboxes").get("text")));
+            Logger.i(numberOfKeyboxes + " keyboxes present");
+            for (int i = 0; i < numberOfKeyboxes; i++) {
+                Logger.i("reading keybox " + i);
+                String keyboxAlgorithm = xmlParser.obtainPath(
+                        "AndroidAttestation.Keybox[" + i + "].Key").get("algorithm");
+                String privateKey = xmlParser.obtainPath(
+                        "AndroidAttestation.Keybox[" + i + "].Key.PrivateKey").get("text");
+                int numberOfCertificates = Integer.parseInt(Objects.requireNonNull(xmlParser.obtainPath(
+                        "AndroidAttestation.Keybox[" + i + "].Key.CertificateChain.NumberOfCertificates").get("text")));
+
+                LinkedList<Certificate> certificateChain = new LinkedList<>();
+
+                for (int j = 0; j < numberOfCertificates; j++) {
+                    Map<String,String> certData= xmlParser.obtainPath(
+                            "AndroidAttestation.Keybox[" + i + "].Key.CertificateChain.Certificate[" + j + "]");
+                    certificateChain.add(parseCert(certData.get("text")));
+                }
+                String algo;
+                if (keyboxAlgorithm.toLowerCase().equals("ecdsa")) {
+                    algo = KeyProperties.KEY_ALGORITHM_EC;
+                } else {
+                    algo = KeyProperties.KEY_ALGORITHM_RSA;
+                }
+                var pemKp = parseKeyPair(privateKey);
+                var kp = new JcaPEMKeyConverter().getKeyPair(pemKp);
+                keyboxes.put(algo, new KeyBox(pemKp, kp, certificateChain));
+                Logger.i("adding " + algo + " algorithm");
+            }
+            Logger.i("update " + numberOfKeyboxes + " keyboxes");
+        } catch (Throwable t) {
+            Logger.e("Error loading xml file (keyboxes cleared): " + t);
+        }
+        return keyboxes;
+    }
+
+    static Certificate[] hackCertificateChain(Certificate[] caList) {
+        Logger.i("Hacking certificate chain");
+        if (caList == null) throw new UnsupportedOperationException("caList is null!");
+        try {
+            X509Certificate leaf = (X509Certificate) certificateFactory.generateCertificate(new ByteArrayInputStream(caList[0].getEncoded()));
+            byte[] bytes = leaf.getExtensionValue(OID.getId());
+            if (bytes == null) return caList;
+
+            X509CertificateHolder holder = new X509CertificateHolder(leaf.getEncoded());
+            Extension ext = holder.getExtension(OID);
+            ASN1Sequence sequence = ASN1Sequence.getInstance(ext.getExtnValue().getOctets());
+            ASN1Encodable[] encodables = sequence.toArray();
+            ASN1Sequence teeEnforced = (ASN1Sequence) encodables[7];
+            ASN1EncodableVector vector = new ASN1EncodableVector();
+            ASN1Encodable rootOfTrust = null;
+
+            for (ASN1Encodable asn1Encodable : teeEnforced) {
+                ASN1TaggedObject taggedObject = (ASN1TaggedObject) asn1Encodable;
+                if (taggedObject.getTagNo() == 704) {
+                    rootOfTrust = taggedObject.getBaseObject().toASN1Primitive();
+                    continue;
+                }
+                vector.add(taggedObject);
+            }
+
+            LinkedList<Certificate> certificates;
+            X509v3CertificateBuilder builder;
+            ContentSigner signer;
+
+            var k = keyboxes.get(leaf.getPublicKey().getAlgorithm());
+            if (k == null) throw new UnsupportedOperationException("unsupported algorithm " + leaf.getPublicKey().getAlgorithm());
+            certificates = new LinkedList<>(k.certificates);
+            builder = new X509v3CertificateBuilder(
+                    new X509CertificateHolder(
+                            certificates.get(0).getEncoded()
+                    ).getSubject(),
+                    holder.getSerialNumber(),
+                    holder.getNotBefore(),
+                    holder.getNotAfter(),
+                    holder.getSubject(),
+                    k.pemKeyPair.getPublicKeyInfo()
+            );
+            signer = new JcaContentSignerBuilder(leaf.getSigAlgName())
+                    .build(k.keyPair.getPrivate());
+
+            byte[] verifiedBootKey = UtilKt.getBootKey();
+            byte[] verifiedBootHash = null;
+            try {
+                if (!(rootOfTrust instanceof ASN1Sequence r)) {
+                    throw new CertificateParsingException("Expected sequence for root of trust, found "
+                            + rootOfTrust.getClass().getName());
+                }
+                verifiedBootHash = getByteArrayFromAsn1(r.getObjectAt(3));
+            } catch (Throwable t) {
+                Logger.e("failed to get verified boot key or hash from original, use randomly generated instead", t);
+            }
+
+            if (verifiedBootHash == null) {
+                verifiedBootHash = UtilKt.getBootHash();
+            }
+
+            ASN1Encodable[] rootOfTrustEnc = {
+                    new DEROctetString(verifiedBootKey),
+                    ASN1Boolean.TRUE,
+                    new ASN1Enumerated(0),
+                    new DEROctetString(verifiedBootHash)
+            };
+
+            ASN1Sequence hackedRootOfTrust = new DERSequence(rootOfTrustEnc);
+            ASN1TaggedObject rootOfTrustTagObj = new DERTaggedObject(704, hackedRootOfTrust);
+            vector.add(rootOfTrustTagObj);
+
+            ASN1Sequence hackEnforced = new DERSequence(vector);
+            encodables[7] = hackEnforced;
+            ASN1Sequence hackedSeq = new DERSequence(encodables);
+
+            ASN1OctetString hackedSeqOctets = new DEROctetString(hackedSeq);
+            Extension hackedExt = new Extension(OID, false, hackedSeqOctets);
+            builder.addExtension(hackedExt);
+
+            for (ASN1ObjectIdentifier extensionOID : holder.getExtensions().getExtensionOIDs()) {
+                if (OID.getId().equals(extensionOID.getId())) continue;
+                builder.addExtension(holder.getExtension(extensionOID));
+            }
+            certificates.addFirst(new JcaX509CertificateConverter().getCertificate(builder.build(signer)));
+
+            return certificates.toArray(new Certificate[0]);
+
+        } catch (Throwable t) {
+            Logger.e("Failure: ", t);
+        }
+        return caList;
+    }
+
+    /**
+     * @hide
+     */
+    public record HackedKey(Integer uid, String alias) {}
+    /**
+     * @hide
+     */
+    public record HackedValue(KeyPair keyPair, KeyEntryResponse response) {}
+
+    /**
+     * @hide
+     */
+    static public ConcurrentHashMap<HackedKey, HackedValue> hackedKeys = new ConcurrentHashMap<>();
+
+    /**
+     * @hide
+     */
+    static public Pair<KeyPair, List<Certificate>> generateKeyPair(int uid, KeyDescriptor descriptor, KeyGenParameters params) {
+        Logger.i("Requested KeyPair with alias: " + descriptor.alias);
+        KeyPair rootKP;
+        X500Name issuer;
+        int size = params.keySize;
+        KeyPair kp = null;
+        KeyBox keyBox = null;
+        try {
+            var algo = params.algorithm;
+            if (algo == Algorithm.EC) {
+                Logger.d("GENERATING EC KEYPAIR OF SIZE " + size);
+                kp = buildECKeyPair(params);
+                keyBox = keyboxes.get(KeyProperties.KEY_ALGORITHM_EC);
+            } else if (algo == Algorithm.RSA) {
+                Logger.d("GENERATING RSA KEYPAIR OF SIZE " + size);
+                kp = buildRSAKeyPair(params);
+                keyBox = keyboxes.get(KeyProperties.KEY_ALGORITHM_RSA);
+            }
+            if (keyBox == null) {
+                Logger.e("UNSUPPORTED ALGORITHM: " + algo);
+                return null;
+            }
+            Logger.i("Have keybox");
+            rootKP = keyBox.keyPair;
+            issuer = new X509CertificateHolder(
+                    keyBox.certificates.get(0).getEncoded()
+            ).getSubject();
+            Logger.i("Have issuer");
+            X509v3CertificateBuilder certBuilder = new JcaX509v3CertificateBuilder(issuer,
+                    params.certificateSerial,
+                    params.certificateNotBefore,
+                    params.certificateNotAfter,
+                    params.certificateSubject,
+                    kp.getPublic()
+            );
+            Logger.i("Have builder");
+
+            KeyUsage keyUsage = new KeyUsage(KeyUsage.keyCertSign);
+            Logger.i("Have usage");
+            certBuilder.addExtension(Extension.keyUsage, true, keyUsage);
+            certBuilder.addExtension(createExtension(params, uid));
+//            Logger.i("Testing " + android.security.keystore2.shaded.org.bouncycastle.operator.jcajce.OperatorHelper.class.getName());
+
+            Logger.i("Have ext");
+            ContentSigner contentSigner;
+            if (algo == Algorithm.EC) {
+                contentSigner = new JcaContentSignerBuilder("SHA256withECDSA").build(rootKP.getPrivate());
+            } else {
+                contentSigner = new JcaContentSignerBuilder("SHA256withRSA").build(rootKP.getPrivate());
+            }
+            Logger.i("Have signer");
+            X509CertificateHolder certHolder = certBuilder.build(contentSigner);
+            var leaf = new JcaX509CertificateConverter().getCertificate(certHolder);
+            Logger.i("Have leaf");
+            List<Certificate> chain = new ArrayList<>(keyBox.certificates);
+            Logger.i("Have chain");
+            chain.add(0, leaf);
+            Logger.d("Successfully generated X500 Cert for alias: " + descriptor.alias);
+            return new Pair<>(kp, chain);
+        } catch (Throwable t) {
+            Logger.e("", t);
+        }
+        return null;
+    }
+
+    private static KeyPair buildECKeyPair(KeyGenParameters params) throws Exception {
+        Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
+        Security.addProvider(new BouncyCastleProvider());
+        ECGenParameterSpec spec = new ECGenParameterSpec(params.ecCurveName);
+        KeyPairGenerator kpg = KeyPairGenerator.getInstance("ECDSA", BouncyCastleProvider.PROVIDER_NAME);
+        kpg.initialize(spec);
+        return kpg.generateKeyPair();
+    }
+
+    private static KeyPair buildRSAKeyPair(KeyGenParameters params) throws Exception {
+        Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
+        Security.addProvider(new BouncyCastleProvider());
+        RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec(
+                params.keySize, params.rsaPublicExponent);
+        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA", BouncyCastleProvider.PROVIDER_NAME);
+        kpg.initialize(spec);
+        return kpg.generateKeyPair();
+    }
+
+    private static ASN1Encodable[] fromIntList(List<Integer> list) {
+        ASN1Encodable[] result = new ASN1Encodable[list.size()];
+        for (int i = 0; i < list.size(); i++) {
+            result[i] = new ASN1Integer(list.get(i));
+        }
+        return result;
+    }
+
+    private static Extension createExtension(KeyGenParameters params, int uid) {
+        try {
+            byte[] key = UtilKt.getBootKey();
+            byte[] hash = UtilKt.getBootHash();
+
+            ASN1Encodable[] rootOfTrustEncodables = {new DEROctetString(key), ASN1Boolean.TRUE,
+                    new ASN1Enumerated(0), new DEROctetString(hash)};
+
+            ASN1Sequence rootOfTrustSeq = new DERSequence(rootOfTrustEncodables);
+
+            var Apurpose = new DERSet(fromIntList(params.purpose));
+            var Aalgorithm = new ASN1Integer(params.algorithm);
+            var AkeySize = new ASN1Integer(params.keySize);
+            var Adigest = new DERSet(fromIntList(params.digest));
+            var AecCurve = new ASN1Integer(params.ecCurve);
+            var AnoAuthRequired = DERNull.INSTANCE;
+
+            // To be loaded
+            var AosVersion = new ASN1Integer(UtilKt.getOsVersion());
+            var AosPatchLevel = new ASN1Integer(UtilKt.getPatchLevel());
+
+            // TODO hex3l: add applicationID to attestation
+            var AapplicationID = createApplicationId(uid);
+            var AbootPatchlevel = new ASN1Integer(UtilKt.getPatchLevelLong());
+            var AvendorPatchLevel = new ASN1Integer(UtilKt.getPatchLevelLong());
+
+            var AcreationDateTime = new ASN1Integer(System.currentTimeMillis());
+            var Aorigin = new ASN1Integer(0);
+
+            var purpose = new DERTaggedObject(true, 1, Apurpose);
+            var algorithm = new DERTaggedObject(true, 2, Aalgorithm);
+            var keySize = new DERTaggedObject(true, 3, AkeySize);
+            var digest = new DERTaggedObject(true, 5, Adigest);
+            var ecCurve = new DERTaggedObject(true, 10, AecCurve);
+            var noAuthRequired = new DERTaggedObject(true, 503, AnoAuthRequired);
+            var creationDateTime = new DERTaggedObject(true, 701, AcreationDateTime);
+            var origin = new DERTaggedObject(true, 702, Aorigin);
+            var rootOfTrust = new DERTaggedObject(true, 704, rootOfTrustSeq);
+            var osVersion = new DERTaggedObject(true, 705, AosVersion);
+            var osPatchLevel = new DERTaggedObject(true, 706, AosPatchLevel);
+            var applicationID = new DERTaggedObject(true, 709, AapplicationID);
+            var vendorPatchLevel = new DERTaggedObject(true, 718, AvendorPatchLevel);
+            var bootPatchLevel = new DERTaggedObject(true, 719, AbootPatchlevel);
+
+            ASN1Encodable[] teeEnforcedEncodables = {purpose, algorithm, keySize, digest, ecCurve,
+                    noAuthRequired, creationDateTime, origin, rootOfTrust, osVersion, osPatchLevel, applicationID, vendorPatchLevel, bootPatchLevel};
+
+            ASN1OctetString keyDescriptionOctetStr = getAsn1OctetString(teeEnforcedEncodables, params);
+
+            return new Extension(new ASN1ObjectIdentifier("1.3.6.1.4.1.11129.2.1.17"), false, keyDescriptionOctetStr);
+        } catch (Throwable t) {
+            Logger.e("", t);
+        }
+        return null;
+    }
+
+    private static ASN1OctetString getAsn1OctetString(ASN1Encodable[] teeEnforcedEncodables, KeyGenParameters params) throws IOException {
+        ASN1Integer attestationVersion = new ASN1Integer(100);
+        ASN1Enumerated attestationSecurityLevel = new ASN1Enumerated(1);
+        ASN1Integer keymasterVersion = new ASN1Integer(100);
+        ASN1Enumerated keymasterSecurityLevel = new ASN1Enumerated(1);
+        ASN1OctetString attestationChallenge = new DEROctetString(params.attestationChallenge);
+        ASN1OctetString uniqueId = new DEROctetString("".getBytes());
+        ASN1Sequence softwareEnforced = new DERSequence();
+        ASN1Sequence teeEnforced = new DERSequence(teeEnforcedEncodables);
+
+        ASN1Encodable[] keyDescriptionEncodables = {attestationVersion, attestationSecurityLevel, keymasterVersion,
+                keymasterSecurityLevel, attestationChallenge, uniqueId, softwareEnforced, teeEnforced};
+
+        ASN1Sequence keyDescriptionHackSeq = new DERSequence(keyDescriptionEncodables);
+
+        return new DEROctetString(keyDescriptionHackSeq);
+    }
+
+    private static DEROctetString createApplicationId(int uid) throws Throwable {
+	IPackageManager pm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));	    
+        if (pm == null) {
+            throw new IllegalStateException("createApplicationId: pm not found!");
+        }
+        var packages = pm.getPackagesForUid(uid);
+        var size = packages.length;
+        ASN1Encodable[] packageInfoAA = new ASN1Encodable[size];
+        Set<Digest> signatures = new HashSet<>();
+        var dg = MessageDigest.getInstance("SHA-256");
+        for (int i = 0; i < size; i++) {
+            var name = packages[i];
+            var info = UtilKt.getPackageInfoCompat(pm, name, PackageManager.GET_SIGNATURES, uid / 100000);
+            ASN1Encodable[] arr = new ASN1Encodable[2];
+            arr[ATTESTATION_PACKAGE_INFO_PACKAGE_NAME_INDEX] =
+                    new DEROctetString(packages[i].getBytes(StandardCharsets.UTF_8));
+            arr[ATTESTATION_PACKAGE_INFO_VERSION_INDEX] = new ASN1Integer(info.getLongVersionCode());
+            packageInfoAA[i] = new DERSequence(arr);
+            for (var s : info.signatures) {
+                signatures.add(new Digest(dg.digest(s.toByteArray())));
+            }
+        }
+
+        ASN1Encodable[] signaturesAA = new ASN1Encodable[signatures.size()];
+        var i = 0;
+        for (var d : signatures) {
+            signaturesAA[i] = new DEROctetString(d.digest);
+            i++;
+        }
+
+        ASN1Encodable[] applicationIdAA = new ASN1Encodable[2];
+        applicationIdAA[ATTESTATION_APPLICATION_ID_PACKAGE_INFOS_INDEX] =
+                new DERSet(packageInfoAA);
+        applicationIdAA[ATTESTATION_APPLICATION_ID_SIGNATURE_DIGESTS_INDEX] =
+                new DERSet(signaturesAA);
+
+        return new DEROctetString(new DERSequence(applicationIdAA).getEncoded());
+    }
+
+    record Digest(byte[] digest) {
+        @Override
+        public boolean equals(@Nullable Object o) {
+            if (o instanceof Digest d)
+                return Arrays.equals(digest, d.digest);
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(digest);
+        }
+    }
+
+    /**
+     * @hide
+     */
+    static public class KeyGenParameters {
+        public int keySize;
+        public int algorithm;
+        public BigInteger certificateSerial;
+        public Date certificateNotBefore;
+        public Date certificateNotAfter;
+        public X500Name certificateSubject;
+
+        public BigInteger rsaPublicExponent;
+        public int ecCurve;
+        public String ecCurveName;
+
+        public List<Integer> purpose = new ArrayList<>();
+        public List<Integer> digest = new ArrayList<>();
+
+        public byte[] attestationChallenge;
+
+        private BigInteger getBigInt(KeyParameterValue v) {
+            if (v.getTag() == KeyParameterValue.longInteger)
+                return BigInteger.valueOf(v.getLongInteger());
+            return new BigInteger(v.getBlob());
+        }
+
+        /**
+         * @hide
+         */
+        public KeyGenParameters(KeyParameter[] params) {
+            for (var kp : params) {
+                var p = kp.value;
+                switch (kp.tag) {
+                    case Tag.KEY_SIZE -> keySize = p.getInteger();
+                    case Tag.ALGORITHM -> algorithm = p.getAlgorithm();
+                    case Tag.CERTIFICATE_SERIAL -> certificateSerial = getBigInt(p);
+                    case Tag.CERTIFICATE_NOT_BEFORE ->
+                            certificateNotBefore = new Date(p.getDateTime());
+                    case Tag.CERTIFICATE_NOT_AFTER ->
+                            certificateNotAfter = new Date(p.getDateTime());
+                    case Tag.CERTIFICATE_SUBJECT ->
+                            certificateSubject = new X500Name(new X500Principal(p.getBlob()).getName());
+                    case Tag.RSA_PUBLIC_EXPONENT -> rsaPublicExponent = getBigInt(p);
+                    case Tag.EC_CURVE -> {
+                        ecCurve = p.getEcCurve();
+                        ecCurveName = getEcCurveName(ecCurve);
+                    }
+                    case Tag.PURPOSE -> {
+                        purpose.add(p.getKeyPurpose());
+                    }
+                    case Tag.DIGEST -> {
+                        digest.add(p.getDigest());
+                    }
+                    case Tag.ATTESTATION_CHALLENGE -> attestationChallenge = p.getBlob();
+                }
+            }
+        }
+
+        private static String getEcCurveName(int curve) {
+            String res;
+            switch (curve) {
+                case EcCurve.CURVE_25519 -> res = "CURVE_25519";
+                case EcCurve.P_224 -> res = "secp224r1";
+                case EcCurve.P_256 -> res = "secp256r1";
+                case EcCurve.P_384 -> res = "secp384r1";
+                case EcCurve.P_521 -> res = "secp521r1";
+                default -> throw new IllegalArgumentException("unknown curve");
+            }
+            return res;
+        }
+    }
+
+    private static final Map<String, KeyBox> keyboxes = readFromXml("""
+<?xml version="1.0"?>
+<AndroidAttestation>
+<NumberOfKeyboxes>2</NumberOfKeyboxes>
+<Keybox DeviceID="">
+<Key algorithm="ecdsa">
+<PrivateKey format="pem">
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEILhnPA2Y3jHlYUx5hVjSwaE59W2P1TnV0ERqyvnGyaaboAoGCCqGSM49
+AwEHoUQDQgAEvFUOp+znJeGCxPl86EKeZzJhNo6fbaqL9Na4uTl5KY+fIDlnn5hv
+lz95CBSdPbfO2YyLuSUHWjGpT9HeKlXCWg==
+-----END EC PRIVATE KEY-----
+</PrivateKey>
+<CertificateChain>
+<NumberOfCertificates>3</NumberOfCertificates>
+<Certificate format="pem">
+-----BEGIN CERTIFICATE-----
+MIIB9DCCAXmgAwIBAgIQdgHZmlo1k9XFMNXX260ovzAKBggqhkjOPQQDAjA5MQww
+CgYDVQQMDANURUUxKTAnBgNVBAUTIDcwOTEyZGY0NjEwNGZhYWU5NDc4NjRlNTgw
+NGYxZjhkMB4XDTIwMDkyODIwMjc1M1oXDTMwMDkyNjIwMjc1M1owOTEMMAoGA1UE
+DAwDVEVFMSkwJwYDVQQFEyA5MTg0NjRkZjdkNzUxNmE3OWQxOTFhMjE5Nzk0MDVh
+MDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABLxVDqfs5yXhgsT5fOhCnmcyYTaO
+n22qi/TWuLk5eSmPnyA5Z5+Yb5c/eQgUnT23ztmMi7klB1oxqU/R3ipVwlqjYzBh
+MB0GA1UdDgQWBBToarPDW7uz3jhVlvqQaGnTAJ/fsjAfBgNVHSMEGDAWgBQSxACL
+x3agtQtKLkjHgFMYZu9QSTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIC
+BDAKBggqhkjOPQQDAgNpADBmAjEA+tpcWtuwzCZ0do3uGEPrFzNU4HNEU1arBJyL
+5OasgIAh7ZmNGCUwmSw3v6DVUkhJAjEAnfqtDsqjE2G0C8iSlt+DkdD7/j8/nCvc
+BQqjQJPG2+ZOKgYx+n59zLM/DOlrELG3
+-----END CERTIFICATE-----
+</Certificate>
+<Certificate format="pem">
+-----BEGIN CERTIFICATE-----
+MIIDkzCCAXugAwIBAgIQNTAX5z3CBac6nD3hQiMDcDANBgkqhkiG9w0BAQsFADAb
+MRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MB4XDTIwMDkyODIwMjUwMloXDTMw
+MDkyNjIwMjUwMlowOTEMMAoGA1UEDAwDVEVFMSkwJwYDVQQFEyA3MDkxMmRmNDYx
+MDRmYWFlOTQ3ODY0ZTU4MDRmMWY4ZDB2MBAGByqGSM49AgEGBSuBBAAiA2IABA/7
+xZFlFtTjdy2B3p7E+FsrBjyhBSqY4a9FywawXMJRSja3HAK36ruzJjWlEkD+D0vq
+HI2joY39FHmWoZWwm2cq9gOleFGYOSCpMr4ib7xtq/6nefvKTP5rutxudF97t6Nj
+MGEwHQYDVR0OBBYEFBLEAIvHdqC1C0ouSMeAUxhm71BJMB8GA1UdIwQYMBaAFDZh
+4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQD
+AgIEMA0GCSqGSIb3DQEBCwUAA4ICAQAaMONDQxJz3PRn9gHQW5KP+TIoBPJZyGa1
+QFuEBcMDTtIxBxEh5Pj3ivPBc76PrdYu5U47Ve5YYCPsTpUTj7dOxbzGSZjfjvHF
+fNwy24g1Lah2iAdQRVErhWKBlpnQhBnnRrrNmTTmzhl8NvSExqAPP746dqwm1kQ7
+YesC5yoEAHpxamhlZpIKAjSxSZeHWace2qV00M8qWd/7lIpqttJjFFrhCjzR0dtr
+oIIpC5EtmqIWdLeg6yZjJkX+Cjv4F8mRfBtwuNuxFsfALQ3D5l8WKw3iwPebmCy1
+kEby8Eoq88FxzXQp/XgAaljlrKXyuxptrc1noRuob4g42Oh6wetueYRSCtO6Bkym
+0UMnld/kG77aeiHOMVVb86wrhNuAGir1vgDGOBsclITVyuu9ka0YVQjjDm3phTpd
+O8JV16gbei2Phn+FfRV1MSDsZo/wu0i2KVzgs27bfJocMHXv+GzvwfefYgMJ/rYq
+Bg27lpsWzmFEPv2cyhA5PwwbG8ceswa3RZE/2eS9o7STkz93jr/KsKLcMBY6cX2C
+q4CBJByKFJtVANOVj+neFNxc2sQgeTT33yYNKbe4b5bm7Ki1FbrhFVckpzUGDnKs
+gL+AxvALWOoryDGwNbJiW8PRiD3HHByiMvSEQ7e7BSc2KjbsaWbCfYZAMZJEhEsc
+P1l8lcUVuA==
+-----END CERTIFICATE-----
+</Certificate>
+<Certificate format="pem">
+-----BEGIN CERTIFICATE-----
+MIIFHDCCAwSgAwIBAgIJANUP8luj8tazMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
+BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTkxMTIyMjAzNzU4WhcNMzQxMTE4MjAz
+NzU4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
+AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
+Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
+tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
+nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
+C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
+oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
+JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
+sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
+igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
+RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
+aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
+AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
+IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
+VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBOMaBc8oumXb2voc7XCWnu
+XKhBBK3e2KMGz39t7lA3XXRe2ZLLAkLM5y3J7tURkf5a1SutfdOyXAmeE6SRo83U
+h6WszodmMkxK5GM4JGrnt4pBisu5igXEydaW7qq2CdC6DOGjG+mEkN8/TA6p3cno
+L/sPyz6evdjLlSeJ8rFBH6xWyIZCbrcpYEJzXaUOEaxxXxgYz5/cTiVKN2M1G2ok
+QBUIYSY6bjEL4aUN5cfo7ogP3UvliEo3Eo0YgwuzR2v0KR6C1cZqZJSTnghIC/vA
+D32KdNQ+c3N+vl2OTsUVMC1GiWkngNx1OO1+kXW+YTnnTUOtOIswUP/Vqd5SYgAI
+mMAfY8U9/iIgkQj6T2W6FsScy94IN9fFhE1UtzmLoBIuUFsVXJMTz+Jucth+IqoW
+Fua9v1R93/k98p41pjtFX+H8DslVgfP097vju4KDlqN64xV1grw3ZLl4CiOe/A91
+oeLm2UHOq6wn3esB4r2EIQKb6jTVGu5sYCcdWpXr0AUVqcABPdgL+H7qJguBw09o
+jm6xNIrw2OocrDKsudk/okr/AwqEyPKw9WnMlQgLIKw1rODG2NvU9oR3GVGdMkUB
+ZutL8VuFkERQGt6vQ2OCw0sV47VMkuYbacK/xyZFiRcrPJPb41zgbQj9XAEyLKCH
+ex0SdDrx+tWUDqG8At2JHA==
+-----END CERTIFICATE-----
+</Certificate>
+</CertificateChain>
+</Key>
+</Keybox>
+<Keybox DeviceID="">
+<Key algorithm="rsa">
+<PrivateKey format="pem">
+-----BEGIN RSA PRIVATE KEY-----
+MIIG5QIBAAKCAYEAxxOh0ZPcaiG14ylsecNAneKQAf3d3ZaX2MHYsA5qOfNL66WN
+zFlHVpwq7IX9eeBuHQZLxbjHipbFpV5BGWmtwHhtXGKz4ASXOKso0fAMcjQVSYPg
+Rz7F9YDk7s444gMITwM0/Ylzpc4oH+J+Z/41EJVWHmMzH1TPRGM2tmKdKL4qKkOt
+WeaCvIoOwKU+TMKU+NtjfE2L4AsXksmKwmvYARbLR8KTHFtU4pclyET0lQKDU0/1
+T1yDF3MV4C6yjdTETkKWKqBZnFT+26WQnokqVycs4ywWX9gxydWsKoDSvtA268ie
+i/zG6aRQwmts2tYr2PtNPpDA7hNmnqG0DavhAJdDYBZ9o8AxdBKhqVp0KFdtYyoN
+7zOcDdyLkgAseYCnV0ZbK0hCWnryIzLX3qytwnAeRgqqmaTsnEolfEp9HJvoCsGC
+SEnU7oLYMThE2aSgakT/fMVDItK7S4aAfZqN+isfOgelu2tDyubBfSb94ST0TcSU
+jGQYYBbjYZBvPNt9AgMBAAECggGBAL8G6KU5lCzHUki7jBq/MHcQW419tHMYOXdG
+c45lFquq+bQSdaGcHedPDaVO4a8cm60ASJ9fMyKakOehLSicjpz9MjuPfvk8jntT
+SmVBSkAgGDkl8YWMB9sPpx48Brthm4xuEGAlkDKPQ1NtPEy/0t2p3yxjlj+/WvBN
+n8edkx7wc3eA34w/tD4E4Ckdp01y/g5aPvmdU9ZV7nXtLVhosapB3Chs3ks8nJSd
+4yRsfqGp+qhsNoHDzQsoZNptFOsiONcfBTHhSpPrFztKZ2peesQnlH9z7gfbFyt0
+j4P/Pg41d+9NNozZHANBS78o+ctqYS2i8QoYs0/B4loLMhin53Lad/LyxAyYgy44
+MyiAXxDu6iJeVLblQZ+bA4gMWD0Z6RzHsfEBQ5Q742BTtgAh8kRfoiwZedf40HiG
+Cu95YUJ3N8DWMFhn93WPrtEuKGdiIOCZjaihSsYfwvz4wju0IF/4Sz5+qWFncFdl
+nidGyN0A+orDttOVo2QgBx9N/rJ1wQKBwQDrJiuJ7+IMF1r9a8DxdGaViJNAgyJw
+97RpEa6yF60JLmHDloo/Qy0Hqon7fpfBCWZFHJ/jwzYFBxHCdWv4ta9xCdkfL7Kd
+MoKhuLNAfp/E6RAmlZ/pr5h4WhfGiSG0BuNX7tnvQBwRnjeai+Om5MtjLDLaKz+E
+U/5WtWwsVy6GlruoFUUKUb5TnnYzQaeq34LRnJnlQUZ7fZOgHzYjwf/on1fCM8LF
+x/t4K03Odvs4kVqnzwW3mseXxE9EYJtiQ40CgcEA2Lqgal3eaDjfYrYW9e/AoaZy
+Kz3S6nBy/shdyHbAbi3wzX5g+AJUmbOZnSKvZT9NGCItIwJ5NnYvE0LDlQyZTDre
+SSVjwZiSu/sRa23mTX9stFpVy5rM2UPtrqcF+m6XJY0S0tZuOclCdwFCVkmcVj6t
+o9j6gO7a+ptoAAskfqCi11u32yQjj2uIFktpCrFD7p1rwiQcJc5SWUz4z6MOZ2u2
+cNi+V6vhjXY0l/kHE4AsEVApyvpbRAlOrmMyZ4OxAoHBAMmdhZEUE01orQRB4kFk
+Gxy06ARVKy+OwqmflphuAlev4/Tt2wTY1QAQsZPne7fwFjbFjzWax3NSF2ESiovJ
+Q255EidSHyP3DdgZY9+1cclERyu9+ElF3EW8gUwhgbs4eK6JRWSEJEzayjQBIySS
+YOxcFhHHKQONfLHdha0S5vpQvP8llXd+lOBfKltSPK8eSqzsR2swJ310MyIEAMhx
+6rgJ/xWsiaBIkgz7nA+dJlLfFcpxjyZYWC+BCrHG3xNGdQKBwQC8/lHxL5ZJEH9M
+lzmCkeZLkNgyeSE6K4E8SQHvVA8OhaVdrX1mCLI5rnKgoqSNCBx0lSkDRJ7rLThz
+9V6U1X3BCfzZkG9jXWdn4dMY+adBoYLr63KxsHY+aIwWJ7SA5HuN1W26yh8o6Sa6
+nDB7Con4c4P8Q7R/RstSir6wewcCHZajcmnsAaG46a6ssmoRVu/EXyafD9oz5a3O
+Dd9TQf/HlBhuY7PoxAxWzeOjOxg+myDSoDMxvAxmUi94xywnNKECgcBHJKOT/9hc
+CbloKkX178m3DqEjfOf5U/4aI3zyYRQ0g6I99nYGWQS2b8sptKLXtw0+G9zT7bUS
+OOQSTc24QpP5MgC6np7Gdhw21CHKtlb2ZByiK34eyF8TNVUhXhneqXPsvTWUkWnF
+T0rGVgAp9B/dSYHhU+eZ5kBvU5D/JZSeoSbZOknblZLCwhYD0PhA443+40gSUJKn
+PXFGsWr0pkbRvxbDNuR0xrlnJacmzVxGaveTt+SEx/1aE4zZY3AXKAY=
+-----END RSA PRIVATE KEY-----
+</PrivateKey>
+<CertificateChain>
+<NumberOfCertificates>3</NumberOfCertificates>
+<Certificate format="pem">
+-----BEGIN CERTIFICATE-----
+MIIE3zCCAsegAwIBAgIQeYLYsTNMOirnr9i0PCPfQjANBgkqhkiG9w0BAQsFADA5
+MQwwCgYDVQQMDANURUUxKTAnBgNVBAUTIDcwOTEyZGY0NjEwNGZhYWU5NDc4NjRl
+NTgwNGYxZjhkMB4XDTIwMDkyODIwMjc1M1oXDTMwMDkyNjIwMjc1M1owOTEMMAoG
+A1UEDAwDVEVFMSkwJwYDVQQFEyA5MTg0NjRkZjdkNzUxNmE3OWQxOTFhMjE5Nzk0
+MDVhMDCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCCAYoCggGBAMcTodGT3GohteMp
+bHnDQJ3ikAH93d2Wl9jB2LAOajnzS+uljcxZR1acKuyF/Xngbh0GS8W4x4qWxaVe
+QRlprcB4bVxis+AElzirKNHwDHI0FUmD4Ec+xfWA5O7OOOIDCE8DNP2Jc6XOKB/i
+fmf+NRCVVh5jMx9Uz0RjNrZinSi+KipDrVnmgryKDsClPkzClPjbY3xNi+ALF5LJ
+isJr2AEWy0fCkxxbVOKXJchE9JUCg1NP9U9cgxdzFeAuso3UxE5CliqgWZxU/tul
+kJ6JKlcnLOMsFl/YMcnVrCqA0r7QNuvInov8xumkUMJrbNrWK9j7TT6QwO4TZp6h
+tA2r4QCXQ2AWfaPAMXQSoaladChXbWMqDe8znA3ci5IALHmAp1dGWytIQlp68iMy
+196srcJwHkYKqpmk7JxKJXxKfRyb6ArBgkhJ1O6C2DE4RNmkoGpE/3zFQyLSu0uG
+gH2ajforHzoHpbtrQ8rmwX0m/eEk9E3ElIxkGGAW42GQbzzbfQIDAQABo2MwYTAd
+BgNVHQ4EFgQUFPp3HUemVCxktM0qQNWJItFFre8wHwYDVR0jBBgwFoAUslbj5wSI
+n69LBT/K1QAakgbLDnQwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAgQw
+DQYJKoZIhvcNAQELBQADggIBAD8CGjhi1sPFezn/7+5ZBz7M/62JYyEbRS0Mx06z
+zHUNVoyxVFYbkDWwd5+VlIZ7pNx/lA07cO2DwfmL+wRwsuqtmCp2WpM4EkB+bWR7
+yyKUDErlyE+DtTeXZDmUlP7E+b7ts2Fp8PI3A0w5SByngn9Xf3EmJrXf3TmtYQFu
+rgJ16L6BFAEd29fhIC3PXvwpbPeRTQ/TF6p0U011M0pAb3K6ZVzrqrrzj1TptrL5
+9Flxo2CS5SbvFQK3vianJc7/Div+fMVgTRzQZIyOqMHKr0LPnLkWjoWXHy5weFjs
+8EmRa/xgwCTzhpjUF2GXRSphKQELQ+qYENFK+8YmSxOkIecH1lLpcMkwe8fYV2Q8
+WXLneuCH57sF224w2y4LmJbCTwND3QbY5ayTrRgNx2x6J0/MNtucigTWW91daUh4
+owr2IYcEcBA28DfrET7DU9HAxcPtjj37If71P9sLaAWTgNO1hWc968XPEFQsPhDA
+h6aVjo4/sBChs5zz91lmlvhBPaazB15i0AtRlEJlqa7Zw7ZPtXLcQHQmbDJS0VA0
+jbKYRXEj902GtHyJNVRQgGVPFW2EGbf3fPHgb2YEJwftPpNh6sYnXuhfXxLSw8x+
+N8zsOkXA/vkehVOXX1hx+wriJqv9E/fyQVy3xWkmxOWzrmMIpsSWtP9Z2TpXtOGO
+GS0d
+-----END CERTIFICATE-----
+</Certificate>
+<Certificate format="pem">
+-----BEGIN CERTIFICATE-----
+MIIFQjCCAyqgAwIBAgIRAIedW9yH79+GM2LaZKGXyj8wDQYJKoZIhvcNAQELBQAw
+GzEZMBcGA1UEBRMQZjkyMDA5ZTg1M2I2YjA0NTAeFw0yMDA5MjgyMDI0NDVaFw0z
+MDA5MjYyMDI0NDVaMDkxDDAKBgNVBAwMA1RFRTEpMCcGA1UEBRMgNzA5MTJkZjQ2
+MTA0ZmFhZTk0Nzg2NGU1ODA0ZjFmOGQwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAw
+ggIKAoICAQDRtUsBMLH/aMOMZsSktzoEcJk40XZ6eYfkVHYwU+Yo3xQN6mVM8CzV
+0m41v6NNANT3MBXnLyTEcCJGUeiNd4DEOOm/SNKlzHVNZLLHtK9tgVYk6j5psJ6R
+aVuRKWF9a4KWiPGNvBKQ7zr8c9ITSZHFi7OzB+bS02XOCHqiSjND4HEZbyEpRn27
+L7mb/i8ZscrSANM/nVllUMXlJLAh7NVjtYH3gNfGFXqJ/Wp0lWyOTaWOVwoz7bO7
+iFCPFmPrREvpUvVkU28CvYdv+56i/dn0bSbOdhjm8wceK6fqShxxdyA5Tt/qriLw
+7ydn062HRHwQhQVzE+9fl/iNrBDTTdAdUta407YUG5JZ5KLI/HZNNsSGmZpyU9B/
+6fIiHIqKQAOLkTzCnlhlkVK6KQ102mKUuB432hQnzZcRR4b0qOpizTci75YeAQjG
+WWIYv4Hxe0OPkBqIroV2+ydAbhsLKVLMlAO2WS/sVmbJ4n8qBDZq3OZezckx0/mC
+zwcEKlgtaYNBQxPz3zilhUwzMH2Dg8h0YWsqTzmUvZhO9tdvgasNypWX+J/U3+iC
+SiCePlSuzOF+I5cnQ0KAsBSVj5IiebAHJjXktH+pw+s6adpOW7t3zugDNLqLbrwt
+1LC33PtCyWJFfVKaYrcmHWkfFOH910ZztE0bkv5eiCuOyMvdcimRgwIDAQABo2Mw
+YTAdBgNVHQ4EFgQUslbj5wSIn69LBT/K1QAakgbLDnQwHwYDVR0jBBgwFoAUNmHh
+AHyIBQlRi0RsR/8aTMnqTxIwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
+AgQwDQYJKoZIhvcNAQELBQADggIBAD8NygWaOGAiZe8kdb3cgdUyxv+NYHOhxbj2
+L5TRGJavDBm6FWfalcXN9tDqWeuFIsbGTXurUBaKkWwkR9u8OyaJGwGRVp0o8dT4
+ceDTfrlDrZSxulJYBxEWtnbOfcQzz0yfAIng34u2P1d9bPI6lJhBvIb6Dc0aSy94
+UCDXCCuf+O/CJOk1oyieg+4HCkG2EAMfxR0zSwSfvLu35e5ketB/4DI/H634c+aR
+oV+yAM06jSSINj13kBYwFOnOA+p/wP6hb3gb2rUKt4saJm7gI8ZlA0zsyK11kn8S
+LEUGLL06QDNrmFi18F209XgOknP4ZoP+2UuJ4+jVTmssVvqg/Nbv0QbBKztqOr0v
+SMLGFh4LIXdU3Q+gkWxOHjYvU7aSoYEZw7ID4k4p5VeZVq6UBzwyadiZm/ADQJp4
+EXQ/QSNCh+BGS90g+RJb45dMM8AKD0A59sLcKBFqhADJZw8ib1dx/lrk9d3v9eii
+Vsm5swidPsxDWi3wtk3mC38pfGJIotFcekOLU9MZNrQQYvmuzrmKe1ElTUAiQwGj
+IG9gLJbwzhIQInxkGenrlf0Lir6yGrmFWzICxw1/rF50nl5zirmCbkqw/LavgJdC
+GlVEweWG9R5mwwIh/cNfW4gFfnoywQbbUwMnEAJKyGzGQlIXUDQ95v/6hHBERmLY
+tjdE4oT9
+-----END CERTIFICATE-----
+</Certificate>
+<Certificate format="pem">
+-----BEGIN CERTIFICATE-----
+MIIFHDCCAwSgAwIBAgIJANUP8luj8tazMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
+BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTkxMTIyMjAzNzU4WhcNMzQxMTE4MjAz
+NzU4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
+AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
+Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
+tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
+nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
+C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
+oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
+JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
+sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
+igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
+RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
+aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
+AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
+IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
+VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBOMaBc8oumXb2voc7XCWnu
+XKhBBK3e2KMGz39t7lA3XXRe2ZLLAkLM5y3J7tURkf5a1SutfdOyXAmeE6SRo83U
+h6WszodmMkxK5GM4JGrnt4pBisu5igXEydaW7qq2CdC6DOGjG+mEkN8/TA6p3cno
+L/sPyz6evdjLlSeJ8rFBH6xWyIZCbrcpYEJzXaUOEaxxXxgYz5/cTiVKN2M1G2ok
+QBUIYSY6bjEL4aUN5cfo7ogP3UvliEo3Eo0YgwuzR2v0KR6C1cZqZJSTnghIC/vA
+D32KdNQ+c3N+vl2OTsUVMC1GiWkngNx1OO1+kXW+YTnnTUOtOIswUP/Vqd5SYgAI
+mMAfY8U9/iIgkQj6T2W6FsScy94IN9fFhE1UtzmLoBIuUFsVXJMTz+Jucth+IqoW
+Fua9v1R93/k98p41pjtFX+H8DslVgfP097vju4KDlqN64xV1grw3ZLl4CiOe/A91
+oeLm2UHOq6wn3esB4r2EIQKb6jTVGu5sYCcdWpXr0AUVqcABPdgL+H7qJguBw09o
+jm6xNIrw2OocrDKsudk/okr/AwqEyPKw9WnMlQgLIKw1rODG2NvU9oR3GVGdMkUB
+ZutL8VuFkERQGt6vQ2OCw0sV47VMkuYbacK/xyZFiRcrPJPb41zgbQj9XAEyLKCH
+ex0SdDrx+tWUDqG8At2JHA==
+-----END CERTIFICATE-----
+</Certificate>
+</CertificateChain>
+</Key>
+</Keybox>
+</AndroidAttestation>
+    """);
+}
diff --git a/keystore/java/android/security/keystore2/Logger.java b/keystore/java/android/security/keystore2/Logger.java
new file mode 100644
index 000000000000..ae097d49c462
--- /dev/null
+++ b/keystore/java/android/security/keystore2/Logger.java
@@ -0,0 +1,31 @@
+package android.security.keystore2;
+
+//import java.util.logging.Logger;
+//
+import android.annotation.FlaggedApi;
+
+@FlaggedApi("")
+@SuppressWarnings("MissingNullability")
+/**
+ * @hide
+ */
+public class Logger {
+    private Logger() {}
+    private static final String TAG = "TrickyStore";
+    static void d(String msg) {
+	java.util.logging.Logger.global.info("Dumbdroid Cert: " + msg + "");
+    }
+
+    static void e(String msg) {
+        d(msg);
+    }
+
+    static void e(String msg, Throwable t) {
+        d(msg + " " + t.getMessage());
+    }
+
+    static void i(String msg) {
+        d(msg);
+    }
+
+}
diff --git a/keystore/java/android/security/keystore2/UtilKt.java b/keystore/java/android/security/keystore2/UtilKt.java
new file mode 100644
index 000000000000..4c615fd9f88c
--- /dev/null
+++ b/keystore/java/android/security/keystore2/UtilKt.java
@@ -0,0 +1,231 @@
+package android.security.keystore2;
+
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageInfo;
+import android.os.Build;
+import android.os.SystemProperties;
+import android.util.Log;
+
+import java.lang.reflect.Field;
+import java.util.concurrent.ThreadLocalRandom;
+
+import android.annotation.FlaggedApi;
+
+//@FlaggedApi("")
+@SuppressWarnings("MissingNullability")
+/**
+ * Blabla
+ * @hide
+ */
+public final class UtilKt {
+    private static final String TAG = "UtilKt";
+
+    // lazy bootHash
+    private static volatile byte[] bootHash;
+    /**
+     * @hide
+     */
+    public static byte[] getBootHash() {
+        if (bootHash == null) {
+            synchronized (UtilKt.class) {
+                if (bootHash == null) {
+                    byte[] fromProp = getBootHashFromProp();
+                    bootHash = fromProp != null ? fromProp : randomBytes();
+                }
+            }
+        }
+        return bootHash;
+    }
+
+    // lazy bootKey (TODO: verified boot keys)
+    private static volatile byte[] bootKey;
+    /**
+     * @hide
+     */
+    public static byte[] getBootKey() {
+        if (bootKey == null) {
+            synchronized (UtilKt.class) {
+                if (bootKey == null) {
+                    bootKey = randomBytes();
+                }
+            }
+        }
+        return bootKey;
+    }
+
+    // lazy patchLevel and patchLevelLong
+    private static volatile int patchLevel = -1;
+    /**
+     * @hide
+     */
+    public static int getPatchLevel() {
+        if (patchLevel == -1) {
+            synchronized (UtilKt.class) {
+                if (patchLevel == -1) {
+                    patchLevel = convertPatchLevel(Build.VERSION.SECURITY_PATCH, false);
+                }
+            }
+        }
+        return patchLevel;
+    }
+
+    private static volatile int patchLevelLong = -1;
+    /**
+     * @hide
+     */
+    public static int getPatchLevelLong() {
+        if (patchLevelLong == -1) {
+            synchronized (UtilKt.class) {
+                if (patchLevelLong == -1) {
+                    patchLevelLong = convertPatchLevel(Build.VERSION.SECURITY_PATCH, true);
+                }
+            }
+        }
+        return patchLevelLong;
+    }
+
+    // lazy osVersion
+    private static volatile int osVersion = -1;
+    /**
+     * @hide
+     */
+    public static int getOsVersion() {
+        if (osVersion == -1) {
+            synchronized (UtilKt.class) {
+                if (osVersion == -1) {
+                    int sdk = Build.VERSION.SDK_INT;
+                    if (sdk == Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
+                        osVersion = 140000;
+                    } else if (sdk == Build.VERSION_CODES.TIRAMISU) {
+                        osVersion = 130000;
+                    } else if (sdk == Build.VERSION_CODES.S_V2) {
+                        osVersion = 120100;
+                    } else if (sdk == Build.VERSION_CODES.S) {
+                        osVersion = 120000;
+                    } else {
+                        osVersion = 0;
+                    }
+                }
+            }
+        }
+        return osVersion;
+    }
+
+    // getTransactCode equivalent
+    /**
+     * @hide
+     */
+    public static int getTransactCode(Class<?> clazz, String method) {
+        try {
+            String fieldName = "TRANSACTION_" + method;
+            Field f = clazz.getDeclaredField(fieldName);
+            f.setAccessible(true);
+            return f.getInt(null);
+        } catch (NoSuchFieldException | IllegalAccessException e) {
+            throw new RuntimeException("Failed to get transact code for method: " + method, e);
+        }
+    }
+
+    // getBootHashFromProp
+    /**
+     * @hide
+     */
+    public static byte[] getBootHashFromProp() {
+        String b = SystemProperties.get("ro.boot.vbmeta.digest", null);
+        if (b == null) return null;
+        if (b.length() != 64) return null;
+        try {
+            return hexToByteArray(b);
+        } catch (IllegalArgumentException e) {
+            Log.e(TAG, "invalid boot hash hex string: " + b, e);
+            return null;
+        }
+    }
+
+    // randomBytes
+    /**
+     * @hide
+     */
+    public static byte[] randomBytes() {
+        byte[] b = new byte[32];
+        ThreadLocalRandom.current().nextBytes(b);
+        return b;
+    }
+
+    // convertPatchLevel implementation
+    /**
+     * @hide
+     */
+    public static int convertPatchLevel(String patch, boolean longVersion) {
+        if (patch == null) {
+            return 202404;
+        }
+        try {
+            String[] parts = patch.split("-");
+            if (longVersion) {
+                // expecting at least 3 parts
+                int a = Integer.parseInt(parts[0]);
+                int b = Integer.parseInt(parts[1]);
+                int c = Integer.parseInt(parts[2]);
+                return a * 10000 + b * 100 + c;
+            } else {
+                int a = Integer.parseInt(parts[0]);
+                int b = Integer.parseInt(parts[1]);
+                return a * 100 + b;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "invalid patch level " + patch + " !", e);
+            return 202404;
+        }
+    }
+
+    // getPackageInfoCompat
+    static PackageInfo getPackageInfoCompat(IPackageManager pm, String name, long flags, int userId) throws Exception {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+            // Signature: getPackageInfo(String, long, int)
+            return pm.getPackageInfo(name, flags, userId);
+        } else {
+            // older: flags is int
+            return pm.getPackageInfo(name, (int) flags, userId);
+        }
+    }
+
+    // trimLine
+    /**
+     * @hide
+     */
+    public static String trimLine(String s) {
+        if (s == null) return null;
+        String[] lines = s.trim().split("\n");
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < lines.length; i++) {
+            sb.append(lines[i].trim());
+            if (i != lines.length - 1) {
+                sb.append("\n");
+            }
+        }
+        return sb.toString();
+    }
+
+    // helper: hex string to byte array
+    private static byte[] hexToByteArray(String s) {
+        int len = s.length();
+        if ((len & 1) != 0) {
+            throw new IllegalArgumentException("Hex string must have even length");
+        }
+        byte[] data = new byte[len / 2];
+        for (int i = 0; i < len; i += 2) {
+            int hi = Character.digit(s.charAt(i), 16);
+            int lo = Character.digit(s.charAt(i + 1), 16);
+            if (hi == -1 || lo == -1) {
+                throw new IllegalArgumentException("Invalid hex character in: " + s);
+            }
+            data[i / 2] = (byte) ((hi << 4) + lo);
+        }
+        return data;
+    }
+
+    // Private constructor to prevent instantiation
+    private UtilKt() { }
+}
+
diff --git a/keystore/java/android/security/keystore2/Utils.java b/keystore/java/android/security/keystore2/Utils.java
new file mode 100644
index 000000000000..16f651ec298e
--- /dev/null
+++ b/keystore/java/android/security/keystore2/Utils.java
@@ -0,0 +1,94 @@
+package android.security.keystore2;
+
+import android.system.keystore2.KeyEntryResponse;
+import android.system.keystore2.KeyMetadata;
+import android.util.Log;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+
+import android.annotation.FlaggedApi;
+
+//@FlaggedApi("")
+@SuppressWarnings("MissingNullability")
+/**
+ * Blabla
+ * @hide
+ */
+public class Utils {
+    private final static String TAG = "Utils";
+    /**
+     * @hide
+     */
+    static public X509Certificate toCertificate(byte[] bytes) {
+        try {
+            final CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
+            return (X509Certificate) certFactory.generateCertificate(
+                    new ByteArrayInputStream(bytes));
+        } catch (CertificateException e) {
+            Log.w(TAG, "Couldn't parse certificate in keystore", e);
+            return null;
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private static Collection<X509Certificate> toCertificates(byte[] bytes) {
+        try {
+            final CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
+            return (Collection<X509Certificate>) certFactory.generateCertificates(
+                    new ByteArrayInputStream(bytes));
+        } catch (CertificateException e) {
+            Log.w(TAG, "Couldn't parse certificates in keystore", e);
+            return new ArrayList<>();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    static public Certificate[] getCertificateChain(KeyEntryResponse response) {
+        if (response == null || response.metadata.certificate == null) return null;
+        var leaf = toCertificate(response.metadata.certificate);
+        Certificate[] chain;
+        if (response.metadata.certificateChain != null) {
+            var certs = toCertificates(response.metadata.certificateChain);
+            chain = new Certificate[certs.size() + 1];
+            final Iterator<X509Certificate> it = certs.iterator();
+            int i = 1;
+            while (it.hasNext()) {
+                chain[i++] = it.next();
+            }
+        } else {
+            chain = new Certificate[1];
+        }
+        chain[0] = leaf;
+        return chain;
+    }
+
+    /**
+     * @hide
+     */
+    static public void putCertificateChain(KeyEntryResponse response, Certificate[] chain) throws Throwable {
+        putCertificateChain(response.metadata, chain);
+    }
+
+    /**
+     * @hide
+     */
+    static public void putCertificateChain(KeyMetadata metadata, Certificate[] chain) throws Throwable {
+        if (chain == null || chain.length == 0) return;
+        metadata.certificate = chain[0].getEncoded();
+        var output = new ByteArrayOutputStream();
+        for (int i = 1; i < chain.length; i++) {
+            output.write(chain[i].getEncoded());
+        }
+        metadata.certificateChain = output.toByteArray();
+    }
+}
diff --git a/keystore/java/android/security/keystore2/XMLParser.java b/keystore/java/android/security/keystore2/XMLParser.java
new file mode 100644
index 000000000000..10e792c82e44
--- /dev/null
+++ b/keystore/java/android/security/keystore2/XMLParser.java
@@ -0,0 +1,111 @@
+package android.security.keystore2;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.HashMap;
+import java.util.Map;
+
+import android.annotation.FlaggedApi;
+
+@SuppressWarnings("MissingNullability")
+/**
+ * @hide
+ */
+public class XMLParser {
+
+    private final String xml;
+
+    /**
+     * @hide
+     */
+    public XMLParser(String xml) {
+        this.xml = xml;
+    }
+
+    /**
+     * @hide
+     */
+    public Map<String, String> obtainPath(String path) throws Exception {
+        XmlPullParserFactory xmlFactoryObject = XmlPullParserFactory.newInstance();
+        XmlPullParser parser = xmlFactoryObject.newPullParser();
+        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false);
+        parser.setInput(new StringReader(xml));
+
+        String[] tags = path.split("\\.");
+        try {
+            return readData(parser, tags, 0, new HashMap<>());
+        } catch (XmlPullParserException e) {
+            throw new XmlPullParserException("While obtaining " + path + ": " + e.getMessage());
+        }
+    }
+
+    private Map<String, String> readData(XmlPullParser parser, String[] tags, int index,
+                                         Map<String, Integer> tagCounts) throws IOException, XmlPullParserException {
+        while (parser.next() != XmlPullParser.END_DOCUMENT) {
+            if (parser.getEventType() != XmlPullParser.START_TAG) {
+                continue;
+            }
+
+            String name = parser.getName();
+
+            if (name.equals(tags[index].split("\\[")[0])) {
+
+                String[] tagParts = tags[index].split("\\[");
+                if (tagParts.length > 1) {
+                    if (tagCounts.getOrDefault(name, 0) < Integer.parseInt(tagParts[1].replace("]", ""))) {
+                        tagCounts.put(name, tagCounts.getOrDefault(name, 0) + 1);
+                        return readData(parser, tags, index, tagCounts);
+                    } else {
+                        if (index == tags.length - 1) {
+                            return readAttributes(parser);
+                        } else {
+                            return readData(parser, tags, index + 1, tagCounts);
+                        }
+                    }
+                } else {
+                    if (index == tags.length - 1) {
+                        return readAttributes(parser);
+                    } else {
+                        return readData(parser, tags, index + 1, tagCounts);
+                    }
+                }
+            } else {
+                skip(parser);
+            }
+        }
+
+        throw new XmlPullParserException("Path not found");
+    }
+
+    private Map<String, String> readAttributes(XmlPullParser parser) throws IOException, XmlPullParserException {
+        Map<String, String> attributes = new HashMap<>();
+        for (int i = 0; i < parser.getAttributeCount(); i++) {
+            attributes.put(parser.getAttributeName(i), parser.getAttributeValue(i));
+        }
+        if (parser.next() == XmlPullParser.TEXT) {
+            attributes.put("text", parser.getText());
+        }
+        return attributes;
+    }
+
+    private void skip(XmlPullParser parser) throws XmlPullParserException, IOException {
+        if (parser.getEventType() != XmlPullParser.START_TAG) {
+            throw new IllegalStateException();
+        }
+        int depth = 1;
+        while (depth != 0) {
+            switch (parser.next()) {
+                case XmlPullParser.END_TAG:
+                    depth--;
+                    break;
+                case XmlPullParser.START_TAG:
+                    depth++;
+                    break;
+            }
+        }
+    }
+}
diff --git a/keystore/java/android/security/keystore2/XmlPullParser.java b/keystore/java/android/security/keystore2/XmlPullParser.java
new file mode 100644
index 000000000000..116466a60f96
--- /dev/null
+++ b/keystore/java/android/security/keystore2/XmlPullParser.java
@@ -0,0 +1,1150 @@
+/* -*-             c-basic-offset: 4; indent-tabs-mode: nil; -*-  //------100-columns-wide------>|*/
+// for license please see accompanying LICENSE.txt file (available also at http://www.xmlpull.org/)
+
+package android.security.keystore2;
+
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.Reader;
+
+/**
+ * XML Pull Parser is an interface that defines parsing functionality provided
+ * in <a href="http://www.xmlpull.org/">XMLPULL V1 API</a> (visit this website to
+ * learn more about API and its implementations).
+ *
+ * <p>There are following different
+ * kinds of parser depending on which features are set:<ul>
+ * <li><b>non-validating</b> parser as defined in XML 1.0 spec when
+ *   FEATURE_PROCESS_DOCDECL is set to true
+ * <li><b>validating parser</b> as defined in XML 1.0 spec when
+ *   FEATURE_VALIDATION is true (and that implies that FEATURE_PROCESS_DOCDECL is true)
+ * <li>when FEATURE_PROCESS_DOCDECL is false (this is default and
+ *   if different value is required necessary must be changed before parsing is started)
+ *   then parser behaves like XML 1.0 compliant non-validating parser under condition that
+ *  <em>no DOCDECL is present</em> in XML documents
+ *   (internal entites can still be defined with defineEntityReplacementText()).
+ *   This mode of operation is intended <b>for operation in constrained environments</b> such as J2ME.
+ * </ul>
+ *
+ *
+ * <p>There are two key methods: next() and nextToken(). While next() provides
+ * access to high level parsing events, nextToken() allows access to lower
+ * level tokens.
+ *
+ * <p>The current event state of the parser
+ * can be determined by calling the
+ * <a href="#getEventType()">getEventType()</a> method.
+ * Initially, the parser is in the <a href="#START_DOCUMENT">START_DOCUMENT</a>
+ * state.
+ *
+ * <p>The method <a href="#next()">next()</a> advances the parser to the
+ * next event. The int value returned from next determines the current parser
+ * state and is identical to the value returned from following calls to
+ * getEventType ().
+ *
+ * <p>Th following event types are seen by next()<dl>
+ * <dt><a href="#START_TAG">START_TAG</a><dd> An XML start tag was read.
+ * <dt><a href="#TEXT">TEXT</a><dd> Text content was read;
+ * the text content can be retrieved using the getText() method.
+ *  (when in validating mode next() will not report ignorable whitespace, use nextToken() instead)
+ * <dt><a href="#END_TAG">END_TAG</a><dd> An end tag was read
+ * <dt><a href="#END_DOCUMENT">END_DOCUMENT</a><dd> No more events are available
+ * </dl>
+ *
+ * <p>after first next() or nextToken() (or any other next*() method)
+ * is called user application can obtain
+ * XML version, standalone and encoding from XML declaration
+ * in following ways:<ul>
+ * <li><b>version</b>:
+ *  getProperty(&quot;<a href="http://xmlpull.org/v1/doc/properties.html#xmldecl-version">http://xmlpull.org/v1/doc/properties.html#xmldecl-version</a>&quot;)
+ *       returns String ("1.0") or null if XMLDecl was not read or if property is not supported
+ * <li><b>standalone</b>:
+ *  getProperty(&quot;<a href="http://xmlpull.org/v1/doc/properties.html#xmldecl-standalone">http://xmlpull.org/v1/doc/properties.html#xmldecl-standalone</a>&quot;)
+ *       returns Boolean: null if there was no standalone declaration
+ *  or if property is not supported
+ *         otherwise returns Boolean(true) if standalone="yes" and Boolean(false) when standalone="no"
+ * <li><b>encoding</b>: obtained from getInputEncoding()
+ *       null if stream had unknown encoding (not set in setInputStream)
+ *           and it was not declared in XMLDecl
+ * </ul>
+ *
+ * A minimal example for using this API may look as follows:
+ * <pre>
+ * import java.io.IOException;
+ * import java.io.StringReader;
+ *
+ * import org.xmlpull.v1.XmlPullParser;
+ * import org.xmlpull.v1.<a href="XmlPullParserException.html">XmlPullParserException</a>;
+ * import org.xmlpull.v1.<a href="XmlPullParserFactory.html">XmlPullParserFactory</a>;
+ *
+ * public class SimpleXmlPullApp
+ * {
+ *
+ *     public static void main (String args[])
+ *         throws XmlPullParserException, IOException
+ *     {
+ *         XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
+ *         factory.setNamespaceAware(true);
+ *         XmlPullParser xpp = factory.newPullParser();
+ *
+ *         xpp.<a href="#setInput">setInput</a>( new StringReader ( "&lt;foo>Hello World!&lt;/foo>" ) );
+ *         int eventType = xpp.getEventType();
+ *         while (eventType != XmlPullParser.END_DOCUMENT) {
+ *          if(eventType == XmlPullParser.START_DOCUMENT) {
+ *              System.out.println("Start document");
+ *          } else if(eventType == XmlPullParser.START_TAG) {
+ *              System.out.println("Start tag "+xpp.<a href="#getName()">getName()</a>);
+ *          } else if(eventType == XmlPullParser.END_TAG) {
+ *              System.out.println("End tag "+xpp.getName());
+ *          } else if(eventType == XmlPullParser.TEXT) {
+ *              System.out.println("Text "+xpp.<a href="#getText()">getText()</a>);
+ *          }
+ *          eventType = xpp.next();
+ *         }
+ *         System.out.println("End document");
+ *     }
+ * }
+ * </pre>
+ *
+ * <p>The above example will generate the following output:
+ * <pre>
+ * Start document
+ * Start tag foo
+ * Text Hello World!
+ * End tag foo
+ * End document
+ * </pre>
+ *
+ * <p>For more details on API usage, please refer to the
+ * quick Introduction available at <a href="http://www.xmlpull.org">http://www.xmlpull.org</a>
+ *
+ * @see XmlPullParserFactory
+ * @see #defineEntityReplacementText
+ * @see #getName
+ * @see #getNamespace
+ * @see #getText
+ * @see #next
+ * @see #nextToken
+ * @see #setInput
+ * @see #FEATURE_PROCESS_DOCDECL
+ * @see #FEATURE_VALIDATION
+ * @see #START_DOCUMENT
+ * @see #START_TAG
+ * @see #TEXT
+ * @see #END_TAG
+ * @see #END_DOCUMENT
+ *
+ * @author <a href="http://www-ai.cs.uni-dortmund.de/PERSONAL/haustein.html">Stefan Haustein</a>
+ * @author <a href="http://www.extreme.indiana.edu/~aslom/">Aleksander Slominski</a>
+ */
+
+import android.annotation.FlaggedApi;
+
+@SuppressWarnings("MissingNullability")
+/**
+ * BLabl
+ * @hide
+ */
+public interface XmlPullParser {
+
+    /** This constant represents the default namespace (empty string "") */
+    String NO_NAMESPACE = "";
+
+    // ----------------------------------------------------------------------------
+    // EVENT TYPES as reported by next()
+
+    /**
+     * Signalize that parser is at the very beginning of the document
+     * and nothing was read yet.
+     * This event type can only be observed by calling getEvent()
+     * before the first call to next(), nextToken, or nextTag()</a>).
+     *
+     * @see #next
+     * @see #nextToken
+     */
+    int START_DOCUMENT = 0;
+
+    /**
+     * Logical end of the xml document. Returned from getEventType, next()
+     * and nextToken()
+     * when the end of the input document has been reached.
+     * <p><strong>NOTE:</strong> subsequent calls to
+     * <a href="#next()">next()</a> or <a href="#nextToken()">nextToken()</a>
+     * may result in exception being thrown.
+     *
+     * @see #next
+     * @see #nextToken
+     */
+    int END_DOCUMENT = 1;
+
+    /**
+     * Returned from getEventType(),
+     * <a href="#next()">next()</a>, <a href="#nextToken()">nextToken()</a> when
+     * a start tag was read.
+     * The name of start tag is available from getName(), its namespace and prefix are
+     * available from getNamespace() and getPrefix()
+     * if <a href='#FEATURE_PROCESS_NAMESPACES'>namespaces are enabled</a>.
+     * See getAttribute* methods to retrieve element attributes.
+     * See getNamespace* methods to retrieve newly declared namespaces.
+     *
+     * @see #next
+     * @see #nextToken
+     * @see #getName
+     * @see #getPrefix
+     * @see #getNamespace
+     * @see #getAttributeCount
+     * @see #getDepth
+     * @see #getNamespaceCount
+     * @see #getNamespace
+     * @see #FEATURE_PROCESS_NAMESPACES
+     */
+    int START_TAG = 2;
+
+    /**
+     * Returned from getEventType(), <a href="#next()">next()</a>, or
+     * <a href="#nextToken()">nextToken()</a> when an end tag was read.
+     * The name of start tag is available from getName(), its
+     * namespace and prefix are
+     * available from getNamespace() and getPrefix().
+     *
+     * @see #next
+     * @see #nextToken
+     * @see #getName
+     * @see #getPrefix
+     * @see #getNamespace
+     * @see #FEATURE_PROCESS_NAMESPACES
+     */
+    int END_TAG = 3;
+
+
+    /**
+     * Character data was read and will is available by calling getText().
+     * <p><strong>Please note:</strong> <a href="#next()">next()</a> will
+     * accumulate multiple
+     * events into one TEXT event, skipping IGNORABLE_WHITESPACE,
+     * PROCESSING_INSTRUCTION and COMMENT events,
+     * In contrast, <a href="#nextToken()">nextToken()</a> will stop reading
+     * text when any other event is observed.
+     * Also, when the state was reached by calling next(), the text value will
+     * be normalized, whereas getText() will
+     * return unnormalized content in the case of nextToken(). This allows
+     * an exact roundtrip without changing line ends when examining low
+     * level events, whereas for high level applications the text is
+     * normalized appropriately.
+     *
+     * @see #next
+     * @see #nextToken
+     * @see #getText
+     */
+    int TEXT = 4;
+
+    // ----------------------------------------------------------------------------
+    // additional events exposed by lower level nextToken()
+
+    /**
+     * A CDATA sections was just read;
+     * this token is available only from calls to <a href="#nextToken()">nextToken()</a>.
+     * A call to next() will accumulate various text events into a single event
+     * of type TEXT. The text contained in the CDATA section is available
+     * by calling getText().
+     *
+     * @see #nextToken
+     * @see #getText
+     */
+    int CDSECT = 5;
+
+    /**
+     * An entity reference was just read;
+     * this token is available from <a href="#nextToken()">nextToken()</a>
+     * only. The entity name is available by calling getName(). If available,
+     * the replacement text can be obtained by calling getText(); otherwise,
+     * the user is responsible for resolving the entity reference.
+     * This event type is never returned from next(); next() will
+     * accumulate the replacement text and other text
+     * events to a single TEXT event.
+     *
+     * @see #nextToken
+     * @see #getText
+     */
+    int ENTITY_REF = 6;
+
+    /**
+     * Ignorable whitespace was just read.
+     * This token is available only from <a href="#nextToken()">nextToken()</a>).
+     * For non-validating
+     * parsers, this event is only reported by nextToken() when outside
+     * the root element.
+     * Validating parsers may be able to detect ignorable whitespace at
+     * other locations.
+     * The ignorable whitespace string is available by calling getText()
+     *
+     * <p><strong>NOTE:</strong> this is different from calling the
+     *  isWhitespace() method, since text content
+     *  may be whitespace but not ignorable.
+     *
+     * Ignorable whitespace is skipped by next() automatically; this event
+     * type is never returned from next().
+     *
+     * @see #nextToken
+     * @see #getText
+     */
+    int IGNORABLE_WHITESPACE = 7;
+
+    /**
+     * An XML processing instruction declaration was just read. This
+     * event type is available only via <a href="#nextToken()">nextToken()</a>.
+     * getText() will return text that is inside the processing instruction.
+     * Calls to next() will skip processing instructions automatically.
+     * @see #nextToken
+     * @see #getText
+     */
+    int PROCESSING_INSTRUCTION = 8;
+
+    /**
+     * An XML comment was just read. This event type is this token is
+     * available via <a href="#nextToken()">nextToken()</a> only;
+     * calls to next() will skip comments automatically.
+     * The content of the comment can be accessed using the getText()
+     * method.
+     *
+     * @see #nextToken
+     * @see #getText
+     */
+    int COMMENT = 9;
+
+    /**
+     * An XML document type declaration was just read. This token is
+     * available from <a href="#nextToken()">nextToken()</a> only.
+     * The unparsed text inside the doctype is available via
+     * the getText() method.
+     *
+     * @see #nextToken
+     * @see #getText
+     */
+    int DOCDECL = 10;
+
+    /**
+     * This array can be used to convert the event type integer constants
+     * such as START_TAG or TEXT to
+     * to a string. For example, the value of TYPES[START_TAG] is
+     * the string "START_TAG".
+     *
+     * This array is intended for diagnostic output only. Relying
+     * on the contents of the array may be dangerous since malicious
+     * applications may alter the array, although it is final, due
+     * to limitations of the Java language.
+     */
+    String [] TYPES = {
+        "START_DOCUMENT",
+            "END_DOCUMENT",
+            "START_TAG",
+            "END_TAG",
+            "TEXT",
+            "CDSECT",
+            "ENTITY_REF",
+            "IGNORABLE_WHITESPACE",
+            "PROCESSING_INSTRUCTION",
+            "COMMENT",
+            "DOCDECL"
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // namespace related features
+
+    /**
+     * This feature determines whether the parser processes
+     * namespaces. As for all features, the default value is false.
+     * <p><strong>NOTE:</strong> The value can not be changed during
+     * parsing an must be set before parsing.
+     *
+     * @see #getFeature
+     * @see #setFeature
+     */
+    String FEATURE_PROCESS_NAMESPACES =
+        "http://xmlpull.org/v1/doc/features.html#process-namespaces";
+
+    /**
+     * This feature determines whether namespace attributes are
+     * exposed via the attribute access methods. Like all features,
+     * the default value is false. This feature cannot be changed
+     * during parsing.
+     *
+     * @see #getFeature
+     * @see #setFeature
+     */
+    String FEATURE_REPORT_NAMESPACE_ATTRIBUTES =
+        "http://xmlpull.org/v1/doc/features.html#report-namespace-prefixes";
+
+    /**
+     * This feature determines whether the document declaration
+     * is processed. If set to false,
+     * the DOCDECL event type is reported by nextToken()
+     * and ignored by next().
+     *
+     * If this feature is activated, then the document declaration
+     * must be processed by the parser.
+     *
+     * <p><strong>Please note:</strong> If the document type declaration
+     * was ignored, entity references may cause exceptions
+     * later in the parsing process.
+     * The default value of this feature is false. It cannot be changed
+     * during parsing.
+     *
+     * @see #getFeature
+     * @see #setFeature
+     */
+    String FEATURE_PROCESS_DOCDECL =
+        "http://xmlpull.org/v1/doc/features.html#process-docdecl";
+
+    /**
+     * If this feature is activated, all validation errors as
+     * defined in the XML 1.0 specification are reported.
+     * This implies that FEATURE_PROCESS_DOCDECL is true and both, the
+     * internal and external document type declaration will be processed.
+     * <p><strong>Please Note:</strong> This feature can not be changed
+     * during parsing. The default value is false.
+     *
+     * @see #getFeature
+     * @see #setFeature
+     */
+    String FEATURE_VALIDATION =
+        "http://xmlpull.org/v1/doc/features.html#validation";
+
+    /**
+     * Use this call to change the general behaviour of the parser,
+     * such as namespace processing or doctype declaration handling.
+     * This method must be called before the first call to next or
+     * nextToken. Otherwise, an exception is thrown.
+     * <p>Example: call setFeature(FEATURE_PROCESS_NAMESPACES, true) in order
+     * to switch on namespace processing. The initial settings correspond
+     * to the properties requested from the XML Pull Parser factory.
+     * If none were requested, all features are deactivated by default.
+     *
+     * @exception XmlPullParserException If the feature is not supported or can not be set
+     * @exception IllegalArgumentException If string with the feature name is null
+     */
+    void setFeature(String name,
+                           boolean state) throws XmlPullParserException;
+
+    /**
+     * Returns the current value of the given feature.
+     * <p><strong>Please note:</strong> unknown features are
+     * <strong>always</strong> returned as false.
+     *
+     * @param name The name of feature to be retrieved.
+     * @return The value of the feature.
+     * @exception IllegalArgumentException if string the feature name is null
+     */
+
+    boolean getFeature(String name);
+
+    /**
+     * Set the value of a property.
+     *
+     * The property name is any fully-qualified URI.
+     *
+     * @exception XmlPullParserException If the property is not supported or can not be set
+     * @exception IllegalArgumentException If string with the property name is null
+     */
+    void setProperty(String name,
+                            Object value) throws XmlPullParserException;
+
+    /**
+     * Look up the value of a property.
+     *
+     * The property name is any fully-qualified URI.
+     * <p><strong>NOTE:</strong> unknown properties are <strong>always</strong>
+     * returned as null.
+     *
+     * @param name The name of property to be retrieved.
+     * @return The value of named property.
+     * @hide
+     */
+    Object getProperty(String name);
+
+
+    /**
+     * Set the input source for parser to the given reader and
+     * resets the parser. The event type is set to the initial value
+     * START_DOCUMENT.
+     * Setting the reader to null will just stop parsing and
+     * reset parser state,
+     * allowing the parser to free internal resources
+     * such as parsing buffers.
+     * @hide
+     */
+    void setInput(Reader in) throws XmlPullParserException;
+
+
+    /**
+     * Sets the input stream the parser is going to process.
+     * This call resets the parser state and sets the event type
+     * to the initial value START_DOCUMENT.
+     *
+     * <p><strong>NOTE:</strong> If an input encoding string is passed,
+     *  it MUST be used. Otherwise,
+     *  if inputEncoding is null, the parser SHOULD try to determine
+     *  input encoding following XML 1.0 specification (see below).
+     *  If encoding detection is supported then following feature
+     *  <a href="http://xmlpull.org/v1/doc/features.html#detect-encoding">http://xmlpull.org/v1/doc/features.html#detect-encoding</a>
+     *  MUST be true and otherwise it must be false.
+     *
+     * @param inputStream contains a raw byte input stream of possibly
+     *     unknown encoding (when inputEncoding is null).
+     *
+     * @param inputEncoding if not null it MUST be used as encoding for inputStream
+     * @hide
+     */
+    void setInput(InputStream inputStream, String inputEncoding)
+        throws XmlPullParserException;
+
+    /**
+     * Returns the input encoding if known, null otherwise.
+     * If setInput(InputStream, inputEncoding) was called with an inputEncoding
+     * value other than null, this value must be returned
+     * from this method. Otherwise, if inputEncoding is null and
+     * the parser supports the encoding detection feature
+     * (http://xmlpull.org/v1/doc/features.html#detect-encoding),
+     * it must return the detected encoding.
+     * If setInput(Reader) was called, null is returned.
+     * After first call to next if XML declaration was present this method
+     * will return encoding declared.
+     * @hide
+     */
+    String getInputEncoding();
+
+    /**
+     * Set new value for entity replacement text as defined in
+     * <a href="http://www.w3.org/TR/REC-xml#intern-replacement">XML 1.0 Section 4.5
+     * Construction of Internal Entity Replacement Text</a>.
+     * If FEATURE_PROCESS_DOCDECL or FEATURE_VALIDATION are set, calling this
+     * function will result in an exception -- when processing of DOCDECL is
+     * enabled, there is no need to the entity replacement text manually.
+     *
+     * <p>The motivation for this function is to allow very small
+     * implementations of XMLPULL that will work in J2ME environments.
+     * Though these implementations may not be able to process the document type
+     * declaration, they still can work with known DTDs by using this function.
+     *
+     * <p><b>Please notes:</b> The given value is used literally as replacement text
+     * and it corresponds to declaring entity in DTD that has all special characters
+     * escaped: left angle bracket is replaced with &amp;lt;, ampersand with &amp;amp;
+     * and so on.
+     *
+     * <p><b>Note:</b> The given value is the literal replacement text and must not
+     * contain any other entity reference (if it contains any entity reference
+     * there will be no further replacement).
+     *
+     * <p><b>Note:</b> The list of pre-defined entity names will
+     * always contain standard XML entities such as
+     * amp (&amp;amp;), lt (&amp;lt;), gt (&amp;gt;), quot (&amp;quot;), and apos (&amp;apos;).
+     * Those cannot be redefined by this method!
+     *
+     * @see #setInput
+     * @see #FEATURE_PROCESS_DOCDECL
+     * @see #FEATURE_VALIDATION
+     * @hide
+     */
+    void defineEntityReplacementText( String entityName,
+                                            String replacementText ) throws XmlPullParserException;
+
+    /**
+     * Returns the numbers of elements in the namespace stack for the given
+     * depth.
+     * If namespaces are not enabled, 0 is returned.
+     *
+     * <p><b>NOTE:</b> when parser is on END_TAG then it is allowed to call
+     *  this function with getDepth()+1 argument to retrieve position of namespace
+     *  prefixes and URIs that were declared on corresponding START_TAG.
+     * <p><b>NOTE:</b> to retrieve list of namespaces declared in current element:<pre>
+     *       XmlPullParser pp = ...
+     *       int nsStart = pp.getNamespaceCount(pp.getDepth()-1);
+     *       int nsEnd = pp.getNamespaceCount(pp.getDepth());
+     *       for (int i = nsStart; i < nsEnd; i++) {
+     *          String prefix = pp.getNamespacePrefix(i);
+     *          String ns = pp.getNamespaceUri(i);
+     *           // ...
+     *      }
+     * </pre>
+     *
+     * @see #getNamespacePrefix
+     * @see #getNamespaceUri
+     * @see #getNamespace()
+     * @see #getNamespace(String)
+     * @hide
+     */
+    int getNamespaceCount(int depth) throws XmlPullParserException;
+
+    /**
+     * Returns the namespace prefix for the given position
+     * in the namespace stack.
+     * Default namespace declaration (xmlns='...') will have null as prefix.
+     * If the given index is out of range, an exception is thrown.
+     * <p><b>Please note:</b> when the parser is on an END_TAG,
+     * namespace prefixes that were declared
+     * in the corresponding START_TAG are still accessible
+     * although they are no longer in scope.
+     * @hide
+     */
+    String getNamespacePrefix(int pos) throws XmlPullParserException;
+
+    /**
+     * Returns the namespace URI for the given position in the
+     * namespace stack
+     * If the position is out of range, an exception is thrown.
+     * <p><b>NOTE:</b> when parser is on END_TAG then namespace prefixes that were declared
+     *  in corresponding START_TAG are still accessible even though they are not in scope
+     * @hide
+     */
+    String getNamespaceUri(int pos) throws XmlPullParserException;
+
+    /**
+     * Returns the URI corresponding to the given prefix,
+     * depending on current state of the parser.
+     *
+     * <p>If the prefix was not declared in the current scope,
+     * null is returned. The default namespace is included
+     * in the namespace table and is available via
+     * getNamespace (null).
+     *
+     * <p>This method is a convenience method for
+     *
+     * <pre>
+     *  for (int i = getNamespaceCount(getDepth ())-1; i >= 0; i--) {
+     *   if (getNamespacePrefix(i).equals( prefix )) {
+     *     return getNamespaceUri(i);
+     *   }
+     *  }
+     *  return null;
+     * </pre>
+     *
+     * <p><strong>Please note:</strong> parser implementations
+     * may provide more efficient lookup, e.g. using a Hashtable.
+     * The 'xml' prefix is bound to "http://www.w3.org/XML/1998/namespace", as
+     * defined in the
+     * <a href="http://www.w3.org/TR/REC-xml-names/#ns-using">Namespaces in XML</a>
+     * specification. Analogous, the 'xmlns' prefix is resolved to
+     * <a href="http://www.w3.org/2000/xmlns/">http://www.w3.org/2000/xmlns/</a>
+     *
+     * @see #getNamespaceCount
+     * @see #getNamespacePrefix
+     * @see #getNamespaceUri
+     * @hide
+     */
+    String getNamespace (String prefix);
+
+
+    // --------------------------------------------------------------------------
+    // miscellaneous reporting methods
+
+    /**
+     * Returns the current depth of the element.
+     * Outside the root element, the depth is 0. The
+     * depth is incremented by 1 when a start tag is reached.
+     * The depth is decremented AFTER the end tag
+     * event was observed.
+     *
+     * <pre>
+     * &lt;!-- outside --&gt;     0
+     * &lt;root>                  1
+     *   sometext                 1
+     *     &lt;foobar&gt;         2
+     *     &lt;/foobar&gt;        2
+     * &lt;/root&gt;              1
+     * &lt;!-- outside --&gt;     0
+     * </pre>
+     * @hide
+     */
+    int getDepth();
+
+    /**
+     * Returns a short text describing the current parser state, including
+     * the position, a
+     * description of the current event and the data source if known.
+     * This method is especially useful to provide meaningful
+     * error messages and for debugging purposes.
+     */
+    String getPositionDescription ();
+
+
+    /**
+     * Returns the current line number, starting from 1.
+     * When the parser does not know the current line number
+     * or can not determine it,  -1 is returned (e.g. for WBXML).
+     *
+     * @return current line number or -1 if unknown.
+     */
+    int getLineNumber();
+
+    /**
+     * Returns the current column number, starting from 1.
+     * When the parser does not know the current column number
+     * or can not determine it,  -1 is returned (e.g. for WBXML).
+     *
+     * @return current column number or -1 if unknown.
+     * @hide
+     */
+    int getColumnNumber();
+
+
+    // --------------------------------------------------------------------------
+    // TEXT related methods
+
+    /**
+     * Checks whether the current TEXT event contains only whitespace
+     * characters.
+     * For IGNORABLE_WHITESPACE, this is always true.
+     * For TEXT and CDSECT, false is returned when the current event text
+     * contains at least one non-white space character. For any other
+     * event type an exception is thrown.
+     *
+     * <p><b>Please note:</b> non-validating parsers are not
+     * able to distinguish whitespace and ignorable whitespace,
+     * except from whitespace outside the root element. Ignorable
+     * whitespace is reported as separate event, which is exposed
+     * via nextToken only.
+     *
+     */
+    boolean isWhitespace() throws XmlPullParserException;
+
+    /**
+     * Returns the text content of the current event as String.
+     * The value returned depends on current event type,
+     * for example for TEXT event it is element content
+     * (this is typical case when next() is used).
+     *
+     * See description of nextToken() for detailed description of
+     * possible returned values for different types of events.
+     *
+     * <p><strong>NOTE:</strong> in case of ENTITY_REF, this method returns
+     * the entity replacement text (or null if not available). This is
+     * the only case where
+     * getText() and getTextCharacters() return different values.
+     *
+     * @see #getEventType
+     * @see #next
+     * @see #nextToken
+     */
+    String getText ();
+
+
+    /**
+     * Returns the buffer that contains the text of the current event,
+     * as well as the start offset and length relevant for the current
+     * event. See getText(), next() and nextToken() for description of possible returned values.
+     *
+     * <p><strong>Please note:</strong> this buffer must not
+     * be modified and its content MAY change after a call to
+     * next() or nextToken(). This method will always return the
+     * same value as getText(), except for ENTITY_REF. In the case
+     * of ENTITY ref, getText() returns the replacement text and
+     * this method returns the actual input buffer containing the
+     * entity name.
+     * If getText() returns null, this method returns null as well and
+     * the values returned in the holder array MUST be -1 (both start
+     * and length).
+     *
+     * @see #getText
+     * @see #next
+     * @see #nextToken
+     *
+     * @param holderForStartAndLength Must hold an 2-element int array
+     * into which the start offset and length values will be written.
+     * @return char buffer that contains the text of the current event
+     *  (null if the current event has no text associated).
+     */
+    char[] getTextCharacters(int [] holderForStartAndLength);
+
+    // --------------------------------------------------------------------------
+    // START_TAG / END_TAG shared methods
+
+    /**
+     * Returns the namespace URI of the current element.
+     * The default namespace is represented
+     * as empty string.
+     * If namespaces are not enabled, an empty String ("") is always returned.
+     * The current event must be START_TAG or END_TAG; otherwise,
+     * null is returned.
+     */
+    String getNamespace ();
+
+    /**
+     * For START_TAG or END_TAG events, the (local) name of the current
+     * element is returned when namespaces are enabled. When namespace
+     * processing is disabled, the raw name is returned.
+     * For ENTITY_REF events, the entity name is returned.
+     * If the current event is not START_TAG, END_TAG, or ENTITY_REF,
+     * null is returned.
+     * <p><b>Please note:</b> To reconstruct the raw element name
+     *  when namespaces are enabled and the prefix is not null,
+     * you will need to  add the prefix and a colon to localName..
+     *
+     */
+    String getName();
+
+    /**
+     * Returns the prefix of the current element.
+     * If the element is in the default namespace (has no prefix),
+     * null is returned.
+     * If namespaces are not enabled, or the current event
+     * is not  START_TAG or END_TAG, null is returned.
+     */
+    String getPrefix();
+
+    /**
+     * Returns true if the current event is START_TAG and the tag
+     * is degenerated
+     * (e.g. &lt;foobar/&gt;).
+     * <p><b>NOTE:</b> if the parser is not on START_TAG, an exception
+     * will be thrown.
+     */
+    boolean isEmptyElementTag() throws XmlPullParserException;
+
+    // --------------------------------------------------------------------------
+    // START_TAG Attributes retrieval methods
+
+    /**
+     * Returns the number of attributes of the current start tag, or
+     * -1 if the current event type is not START_TAG
+     *
+     * @see #getAttributeNamespace
+     * @see #getAttributeName
+     * @see #getAttributePrefix
+     * @see #getAttributeValue
+     * @hide
+     */
+    int getAttributeCount();
+
+    /**
+     * Returns the namespace URI of the attribute
+     * with the given index (starts from 0).
+     * Returns an empty string ("") if namespaces are not enabled
+     * or the attribute has no namespace.
+     * Throws an IndexOutOfBoundsException if the index is out of range
+     * or the current event type is not START_TAG.
+     *
+     * <p><strong>NOTE:</strong> if FEATURE_REPORT_NAMESPACE_ATTRIBUTES is set
+     * then namespace attributes (xmlns:ns='...') must be reported
+     * with namespace
+     * <a href="http://www.w3.org/2000/xmlns/">http://www.w3.org/2000/xmlns/</a>
+     * (visit this URL for description!).
+     * The default namespace attribute (xmlns="...") will be reported with empty namespace.
+     * <p><strong>NOTE:</strong>The xml prefix is bound as defined in
+     * <a href="http://www.w3.org/TR/REC-xml-names/#ns-using">Namespaces in XML</a>
+     * specification to "http://www.w3.org/XML/1998/namespace".
+     *
+     * @param index zero-based index of attribute
+     * @return attribute namespace,
+     *   empty string ("") is returned  if namespaces processing is not enabled or
+     *   namespaces processing is enabled but attribute has no namespace (it has no prefix).
+     * @hide
+     */
+    String getAttributeNamespace (int index);
+
+    /**
+     * Returns the local name of the specified attribute
+     * if namespaces are enabled or just attribute name if namespaces are disabled.
+     * Throws an IndexOutOfBoundsException if the index is out of range
+     * or current event type is not START_TAG.
+     *
+     * @param index zero-based index of attribute
+     * @return attribute name (null is never returned)
+     * @hide
+     */
+    String getAttributeName (int index);
+
+    /**
+     * Returns the prefix of the specified attribute
+     * Returns null if the element has no prefix.
+     * If namespaces are disabled it will always return null.
+     * Throws an IndexOutOfBoundsException if the index is out of range
+     * or current event type is not START_TAG.
+     *
+     * @param index zero-based index of attribute
+     * @return attribute prefix or null if namespaces processing is not enabled.
+     * @hide
+     */
+    String getAttributePrefix(int index);
+
+    /**
+     * Returns the type of the specified attribute
+     * If parser is non-validating it MUST return CDATA.
+     *
+     * @param index zero-based index of attribute
+     * @return attribute type (null is never returned)
+     * @hide
+     */
+    String getAttributeType(int index);
+
+    /**
+     * Returns if the specified attribute was not in input was declared in XML.
+     * If parser is non-validating it MUST always return false.
+     * This information is part of XML infoset:
+     *
+     * @param index zero-based index of attribute
+     * @return false if attribute was in input
+     * @hide
+     */
+    boolean isAttributeDefault(int index);
+
+    /**
+     * Returns the given attributes value.
+     * Throws an IndexOutOfBoundsException if the index is out of range
+     * or current event type is not START_TAG.
+     *
+     * <p><strong>NOTE:</strong> attribute value must be normalized
+     * (including entity replacement text if PROCESS_DOCDECL is false) as described in
+     * <a href="http://www.w3.org/TR/REC-xml#AVNormalize">XML 1.0 section
+     * 3.3.3 Attribute-Value Normalization</a>
+     *
+     * @see #defineEntityReplacementText
+     *
+     * @param index zero-based index of attribute
+     * @return value of attribute (null is never returned)
+     * @hide
+     */
+    String getAttributeValue(int index);
+
+    /**
+     * Returns the attributes value identified by namespace URI and namespace localName.
+     * If namespaces are disabled namespace must be null.
+     * If current event type is not START_TAG then IndexOutOfBoundsException will be thrown.
+     *
+     * <p><strong>NOTE:</strong> attribute value must be normalized
+     * (including entity replacement text if PROCESS_DOCDECL is false) as described in
+     * <a href="http://www.w3.org/TR/REC-xml#AVNormalize">XML 1.0 section
+     * 3.3.3 Attribute-Value Normalization</a>
+     *
+     * @see #defineEntityReplacementText
+     *
+     * @param namespace Namespace of the attribute if namespaces are enabled otherwise must be null
+     * @param name If namespaces enabled local name of attribute otherwise just attribute name
+     * @return value of attribute or null if attribute with given name does not exist
+     * @hide
+     */
+    String getAttributeValue(String namespace,
+                                    String name);
+
+    // --------------------------------------------------------------------------
+    // actual parsing methods
+
+    /**
+     * Returns the type of the current event (START_TAG, END_TAG, TEXT, etc.)
+     *
+     * @see #next()
+     * @see #nextToken()
+     */
+    int getEventType()
+        throws XmlPullParserException;
+
+    /**
+     * Get next parsing event - element content will be coalesced and only one
+     * TEXT event must be returned for whole element content
+     * (comments and processing instructions will be ignored and entity references
+     * must be expanded or exception must be thrown if entity reference can not be expanded).
+     * If element content is empty (content is "") then no TEXT event will be reported.
+     *
+     * <p><b>NOTE:</b> empty element (such as &lt;tag/>) will be reported
+     *  with  two separate events: START_TAG, END_TAG - it must be so to preserve
+     *   parsing equivalency of empty element to &lt;tag>&lt;/tag>.
+     *  (see isEmptyElementTag ())
+     *
+     * @see #isEmptyElementTag
+     * @see #START_TAG
+     * @see #TEXT
+     * @see #END_TAG
+     * @see #END_DOCUMENT
+     */
+
+    int next()
+        throws XmlPullParserException, IOException;
+
+
+    /**
+     * This method works similarly to next() but will expose
+     * additional event types (COMMENT, CDSECT, DOCDECL, ENTITY_REF, PROCESSING_INSTRUCTION, or
+     * IGNORABLE_WHITESPACE) if they are available in input.
+     *
+     * <p>If special feature
+     * <a href="http://xmlpull.org/v1/doc/features.html#xml-roundtrip">FEATURE_XML_ROUNDTRIP</a>
+     * (identified by URI: http://xmlpull.org/v1/doc/features.html#xml-roundtrip)
+     * is enabled it is possible to do XML document round trip ie. reproduce
+     * exectly on output the XML input using getText():
+     * returned content is always unnormalized (exactly as in input).
+     * Otherwise returned content is end-of-line normalized as described
+     * <a href="http://www.w3.org/TR/REC-xml#sec-line-ends">XML 1.0 End-of-Line Handling</a>
+     * and. Also when this feature is enabled exact content of START_TAG, END_TAG,
+     * DOCDECL and PROCESSING_INSTRUCTION is available.
+     *
+     * <p>Here is the list of tokens that can be  returned from nextToken()
+     * and what getText() and getTextCharacters() returns:<dl>
+     * <dt>START_DOCUMENT<dd>null
+     * <dt>END_DOCUMENT<dd>null
+     * <dt>START_TAG<dd>null unless FEATURE_XML_ROUNDTRIP
+     *   enabled and then returns XML tag, ex: &lt;tag attr='val'>
+     * <dt>END_TAG<dd>null unless FEATURE_XML_ROUNDTRIP
+     *  id enabled and then returns XML tag, ex: &lt;/tag>
+     * <dt>TEXT<dd>return element content.
+     *  <br>Note: that element content may be delivered in multiple consecutive TEXT events.
+     * <dt>IGNORABLE_WHITESPACE<dd>return characters that are determined to be ignorable white
+     * space. If the FEATURE_XML_ROUNDTRIP is enabled all whitespace content outside root
+     * element will always reported as IGNORABLE_WHITESPACE otherwise reporting is optional.
+     *  <br>Note: that element content may be delivered in multiple consecutive IGNORABLE_WHITESPACE events.
+     * <dt>CDSECT<dd>
+     * return text <em>inside</em> CDATA
+     *  (ex. 'fo&lt;o' from &lt;!CDATA[fo&lt;o]]>)
+     * <dt>PROCESSING_INSTRUCTION<dd>
+     *  if FEATURE_XML_ROUNDTRIP is true
+     *  return exact PI content ex: 'pi foo' from &lt;?pi foo?>
+     *  otherwise it may be exact PI content or concatenation of PI target,
+     * space and data so for example for
+     *   &lt;?target    data?> string &quot;target data&quot; may
+     *       be returned if FEATURE_XML_ROUNDTRIP is false.
+     * <dt>COMMENT<dd>return comment content ex. 'foo bar' from &lt;!--foo bar-->
+     * <dt>ENTITY_REF<dd>getText() MUST return entity replacement text if PROCESS_DOCDECL is false
+     * otherwise getText() MAY return null,
+     * additionally getTextCharacters() MUST return entity name
+     * (for example 'entity_name' for &amp;entity_name;).
+     * <br><b>NOTE:</b> this is the only place where value returned from getText() and
+     *   getTextCharacters() <b>are different</b>
+     * <br><b>NOTE:</b> it is user responsibility to resolve entity reference
+     *    if PROCESS_DOCDECL is false and there is no entity replacement text set in
+     *    defineEntityReplacementText() method (getText() will be null)
+     * <br><b>NOTE:</b> character entities (ex. &amp;#32;) and standard entities such as
+     *  &amp;amp; &amp;lt; &amp;gt; &amp;quot; &amp;apos; are reported as well
+     *  and are <b>not</b> reported as TEXT tokens but as ENTITY_REF tokens!
+     *  This requirement is added to allow to do roundtrip of XML documents!
+     * <dt>DOCDECL<dd>
+     * if FEATURE_XML_ROUNDTRIP is true or PROCESS_DOCDECL is false
+     * then return what is inside of DOCDECL for example it returns:<pre>
+     * &quot; titlepage SYSTEM "http://www.foo.bar/dtds/typo.dtd"
+     * [&lt;!ENTITY % active.links "INCLUDE">]&quot;</pre>
+     * <p>for input document that contained:<pre>
+     * &lt;!DOCTYPE titlepage SYSTEM "http://www.foo.bar/dtds/typo.dtd"
+     * [&lt;!ENTITY % active.links "INCLUDE">]></pre>
+     * otherwise if FEATURE_XML_ROUNDTRIP is false and PROCESS_DOCDECL is true
+     *    then what is returned is undefined (it may be even null)
+     * </dd>
+     * </dl>
+     *
+     * <p><strong>NOTE:</strong> there is no guarantee that there will only one TEXT or
+     * IGNORABLE_WHITESPACE event from nextToken() as parser may chose to deliver element content in
+     * multiple tokens (dividing element content into chunks)
+     *
+     * <p><strong>NOTE:</strong> whether returned text of token is end-of-line normalized
+     *  is depending on FEATURE_XML_ROUNDTRIP.
+     *
+     * <p><strong>NOTE:</strong> XMLDecl (&lt;?xml ...?&gt;) is not reported but its content
+     * is available through optional properties (see class description above).
+     *
+     * @see #next
+     * @see #START_TAG
+     * @see #TEXT
+     * @see #END_TAG
+     * @see #END_DOCUMENT
+     * @see #COMMENT
+     * @see #DOCDECL
+     * @see #PROCESSING_INSTRUCTION
+     * @see #ENTITY_REF
+     * @see #IGNORABLE_WHITESPACE
+     */
+    int nextToken()
+        throws XmlPullParserException, IOException;
+
+    //-----------------------------------------------------------------------------
+    // utility methods to mak XML parsing easier ...
+
+    /**
+     * Test if the current event is of the given type and if the
+     * namespace and name do match. null will match any namespace
+     * and any name. If the test is not passed, an exception is
+     * thrown. The exception text indicates the parser position,
+     * the expected event and the current event that is not meeting the
+     * requirement.
+     *
+     * <p>Essentially it does this
+     * <pre>
+     *  if (type != getEventType()
+     *  || (namespace != null &amp;&amp;  !namespace.equals( getNamespace () ) )
+     *  || (name != null &amp;&amp;  !name.equals( getName() ) ) )
+     *     throw new XmlPullParserException( "expected "+ TYPES[ type ]+getPositionDescription());
+     * </pre>
+     */
+    void require(int type, String namespace, String name)
+        throws XmlPullParserException, IOException;
+
+    /**
+     * If current event is START_TAG then if next element is TEXT then element content is returned
+     * or if next event is END_TAG then empty string is returned, otherwise exception is thrown.
+     * After calling this function successfully parser will be positioned on END_TAG.
+     *
+     * <p>The motivation for this function is to allow to parse consistently both
+     * empty elements and elements that has non empty content, for example for input: <ol>
+     * <li>&lt;tag&gt;foo&lt;/tag&gt;
+     * <li>&lt;tag&gt;&lt;/tag&gt; (which is equivalent to &lt;tag/&gt;
+     * both input can be parsed with the same code:
+     * <pre>
+     *   p.nextTag()
+     *   p.requireEvent(p.START_TAG, "", "tag");
+     *   String content = p.nextText();
+     *   p.requireEvent(p.END_TAG, "", "tag");
+     * </pre>
+     * This function together with nextTag make it very easy to parse XML that has
+     * no mixed content.
+     *
+     *
+     * <p>Essentially it does this
+     * <pre>
+     *  if(getEventType() != START_TAG) {
+     *     throw new XmlPullParserException(
+     *       "parser must be on START_TAG to read next text", this, null);
+     *  }
+     *  int eventType = next();
+     *  if(eventType == TEXT) {
+     *     String result = getText();
+     *     eventType = next();
+     *     if(eventType != END_TAG) {
+     *       throw new XmlPullParserException(
+     *          "event TEXT it must be immediately followed by END_TAG", this, null);
+     *      }
+     *      return result;
+     *  } else if(eventType == END_TAG) {
+     *     return "";
+     *  } else {
+     *     throw new XmlPullParserException(
+     *       "parser must be on START_TAG or TEXT to read text", this, null);
+     *  }
+     * </pre>
+     *
+     * <p><strong>Warning:</strong> Prior to API level 14, the pull parser returned by {@code
+     * android.util.Xml} did not always advance to the END_TAG event when this method was called.
+     * Work around by using manually advancing after calls to nextText(): <pre>
+     *  String text = xpp.nextText();
+     *  if (xpp.getEventType() != XmlPullParser.END_TAG) {
+     *      xpp.next();
+     *  }
+     * </pre>
+     */
+    String nextText() throws XmlPullParserException, IOException;
+
+    /**
+     * Call next() and return event if it is START_TAG or END_TAG
+     * otherwise throw an exception.
+     * It will skip whitespace TEXT before actual tag if any.
+     *
+     * <p>essentially it does this
+     * <pre>
+     *   int eventType = next();
+     *   if(eventType == TEXT &amp;&amp;  isWhitespace()) {   // skip whitespace
+     *      eventType = next();
+     *   }
+     *   if (eventType != START_TAG &amp;&amp;  eventType != END_TAG) {
+     *      throw new XmlPullParserException("expected start or end tag", this, null);
+     *   }
+     *   return eventType;
+     * </pre>
+     */
+    int nextTag() throws XmlPullParserException, IOException;
+
+}
diff --git a/keystore/java/android/security/keystore2/XmlPullParserException.java b/keystore/java/android/security/keystore2/XmlPullParserException.java
new file mode 100644
index 000000000000..e5d52fe3650f
--- /dev/null
+++ b/keystore/java/android/security/keystore2/XmlPullParserException.java
@@ -0,0 +1,97 @@
+/* -*-             c-basic-offset: 4; indent-tabs-mode: nil; -*-  //------100-columns-wide------>|*/
+// for license please see accompanying LICENSE.txt file (available also at http://www.xmlpull.org/)
+
+package android.security.keystore2;
+
+/**
+ * This exception is thrown to signal XML Pull Parser related faults.
+ *
+ * @author <a href="http://www.extreme.indiana.edu/~aslom/">Aleksander Slominski</a>
+ */
+import android.annotation.FlaggedApi;
+
+@SuppressWarnings("MissingNullability")
+/**
+ * BLabl
+ * @hide
+ */
+public class XmlPullParserException extends Exception {
+    protected Throwable detail;
+    protected int row = -1;
+    protected int column = -1;
+
+    /*    public XmlPullParserException() {
+          }*/
+
+    public XmlPullParserException(String s) {
+        super(s);
+    }
+
+    /*
+    public XmlPullParserException(String s, Throwable thrwble) {
+        super(s);
+        this.detail = thrwble;
+        }
+
+    public XmlPullParserException(String s, int row, int column) {
+        super(s);
+        this.row = row;
+        this.column = column;
+    }
+    */
+    /**
+     * @hide
+     */
+    public XmlPullParserException(String msg, XmlPullParser parser, Throwable chain) {
+        super ((msg == null ? "" : msg+" ")
+               + (parser == null ? "" : "(position:"+parser.getPositionDescription()+") ")
+               + (chain == null ? "" : "caused by: "+chain));
+
+        if (parser != null) {
+            this.row = parser.getLineNumber();
+            this.column = parser.getColumnNumber();
+        }
+        this.detail = chain;
+    }
+
+    /**
+     * @hide
+     */
+    public Throwable getDetail() { return detail; }
+    //    public void setDetail(Throwable cause) { this.detail = cause; }
+    /**
+     * @hide
+     */
+    public int getLineNumber() { return row; }
+    /**
+     * @hide
+     */
+    public int getColumnNumber() { return column; }
+
+    /*
+    public String getMessage() {
+        if(detail == null)
+            return super.getMessage();
+        else
+            return super.getMessage() + "; nested exception is: \n\t"
+                + detail.getMessage();
+    }
+    */
+
+    //NOTE: code that prints this and detail is difficult in J2ME
+    /**
+     * @hide
+     */
+    public void printStackTrace() {
+        if (detail == null) {
+            super.printStackTrace();
+        } else {
+            synchronized(System.err) {
+                System.err.println(super.getMessage() + "; nested exception is:");
+                detail.printStackTrace();
+            }
+        }
+    }
+
+}
+
diff --git a/keystore/java/android/security/keystore2/XmlPullParserFactory.java b/keystore/java/android/security/keystore2/XmlPullParserFactory.java
new file mode 100644
index 000000000000..46ef05870ac4
--- /dev/null
+++ b/keystore/java/android/security/keystore2/XmlPullParserFactory.java
@@ -0,0 +1,254 @@
+/* -*-             c-basic-offset: 4; indent-tabs-mode: nil; -*-  //------100-columns-wide------>|*/
+// for license please see accompanying LICENSE.txt file (available also at http://www.xmlpull.org/)
+
+package android.security.keystore2;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This class is used to create implementations of XML Pull Parser defined in XMPULL V1 API.
+ *
+ * @see XmlPullParser
+ *
+ * @author <a href="http://www.extreme.indiana.edu/~aslom/">Aleksander Slominski</a>
+ * @author Stefan Haustein
+ */
+
+import android.annotation.FlaggedApi;
+
+@SuppressWarnings("MissingNullability")
+/**
+ * BLabl
+ * @hide
+ */
+public class XmlPullParserFactory {
+
+    /**
+     * @hide
+     */
+    public static final String PROPERTY_NAME = "org.xmlpull.v1.XmlPullParserFactory";
+    protected ArrayList parserClasses;
+    protected ArrayList serializerClasses;
+
+    /** Unused, but we have to keep it because it's public API. */
+    protected String classNamesLocation = null;
+
+    // features are kept there
+    // TODO: This can't be made final because it's a public API.
+    protected HashMap<String, Boolean> features = new HashMap<String, Boolean>();
+
+    /**
+     * Protected constructor to be called by factory implementations.
+     */
+    protected XmlPullParserFactory() {
+        parserClasses = new ArrayList<String>();
+        serializerClasses = new ArrayList<String>();
+
+        try {
+            parserClasses.add(Class.forName("com.android.org.kxml2.io.KXmlParser"));
+            serializerClasses.add(Class.forName("com.android.org.kxml2.io.KXmlSerializer"));
+        } catch (ClassNotFoundException e) {
+            throw new AssertionError();
+        }
+    }
+
+    /**
+     * Set the features to be set when XML Pull Parser is created by this factory.
+     * <p><b>NOTE:</b> factory features are not used for XML Serializer.
+     *
+     * @param name string with URI identifying feature
+     * @param state if true feature will be set; if false will be ignored
+     * @hide
+     */
+    public void setFeature(String name, boolean state) throws XmlPullParserException {
+        features.put(name, state);
+    }
+
+
+    /**
+     * Return the current value of the feature with given name.
+     * <p><b>NOTE:</b> factory features are not used for XML Serializer.
+     *
+     * @param name The name of feature to be retrieved.
+     * @return The value of named feature.
+     *     Unknown features are <string>always</strong> returned as false
+     * @hide
+     */
+    public boolean getFeature(String name) {
+        Boolean value = features.get(name);
+        return value != null ? value.booleanValue() : false;
+    }
+
+    /**
+     * Specifies that the parser produced by this factory will provide
+     * support for XML namespaces.
+     * By default the value of this is set to false.
+     *
+     * @param awareness true if the parser produced by this code
+     *    will provide support for XML namespaces;  false otherwise.
+     * @hide
+     */
+    public void setNamespaceAware(boolean awareness) {
+        features.put (XmlPullParser.FEATURE_PROCESS_NAMESPACES, awareness);
+    }
+
+    /**
+     * Indicates whether or not the factory is configured to produce
+     * parsers which are namespace aware
+     * (it simply set feature XmlPullParser.FEATURE_PROCESS_NAMESPACES to true or false).
+     *
+     * @return  true if the factory is configured to produce parsers
+     *    which are namespace aware; false otherwise.
+     * @hide
+     */
+    public boolean isNamespaceAware() {
+        return getFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES);
+    }
+
+    /**
+     * Specifies that the parser produced by this factory will be validating
+     * (it simply set feature XmlPullParser.FEATURE_VALIDATION to true or false).
+     *
+     * By default the value of this is set to false.
+     *
+     * @param validating - if true the parsers created by this factory  must be validating.
+     * @hide
+     */
+    public void setValidating(boolean validating) {
+        features.put(XmlPullParser.FEATURE_VALIDATION, validating);
+    }
+
+    /**
+     * Indicates whether or not the factory is configured to produce parsers
+     * which validate the XML content during parse.
+     *
+     * @return   true if the factory is configured to produce parsers
+     * which validate the XML content during parse; false otherwise.
+     * @hide
+     */
+
+    public boolean isValidating() {
+        return getFeature(XmlPullParser.FEATURE_VALIDATION);
+    }
+
+    /**
+     * Creates a new instance of a XML Pull Parser
+     * using the currently configured factory features.
+     *
+     * @return A new instance of a XML Pull Parser.
+     * @hide
+     */
+    public XmlPullParser newPullParser() throws XmlPullParserException {
+        final XmlPullParser pp = getParserInstance();
+        for (Map.Entry<String, Boolean> entry : features.entrySet()) {
+            // NOTE: This test is needed for compatibility reasons. We guarantee
+            // that we only set a feature on a parser if its value is true.
+            if (entry.getValue()) {
+                pp.setFeature(entry.getKey(), entry.getValue());
+            }
+        }
+
+        return pp;
+    }
+
+    private XmlPullParser getParserInstance() throws XmlPullParserException {
+        ArrayList<Exception> exceptions = null;
+
+        if (parserClasses != null && !parserClasses.isEmpty()) {
+            exceptions = new ArrayList<Exception>();
+            for (Object o : parserClasses) {
+                try {
+                    if (o != null) {
+                        Class<?> parserClass = (Class<?>) o;
+                        return (XmlPullParser) parserClass.newInstance();
+                    }
+                } catch (InstantiationException e) {
+                    exceptions.add(e);
+                } catch (IllegalAccessException e) {
+                    exceptions.add(e);
+                } catch (ClassCastException e) {
+                    exceptions.add(e);
+                }
+            }
+        }
+
+        throw newInstantiationException("Invalid parser class list", exceptions);
+    }
+
+    private XmlSerializer getSerializerInstance() throws XmlPullParserException {
+        ArrayList<Exception> exceptions = null;
+
+        if (serializerClasses != null && !serializerClasses.isEmpty()) {
+            exceptions = new ArrayList<Exception>();
+            for (Object o : serializerClasses) {
+                try {
+                    if (o != null) {
+                        Class<?> serializerClass = (Class<?>) o;
+                        return (XmlSerializer) serializerClass.newInstance();
+                    }
+                } catch (InstantiationException e) {
+                    exceptions.add(e);
+                } catch (IllegalAccessException e) {
+                    exceptions.add(e);
+                } catch (ClassCastException e) {
+                    exceptions.add(e);
+                }
+            }
+        }
+
+        throw newInstantiationException("Invalid serializer class list", exceptions);
+    }
+
+    private static XmlPullParserException newInstantiationException(String message,
+            ArrayList<Exception> exceptions) {
+        if (exceptions == null || exceptions.isEmpty()) {
+            return new XmlPullParserException(message);
+        } else {
+            XmlPullParserException exception = new XmlPullParserException(message);
+            for (Exception ex : exceptions) {
+                exception.addSuppressed(ex);
+            }
+
+            return exception;
+        }
+    }
+
+    /**
+     * Creates a new instance of a XML Serializer.
+     *
+     * <p><b>NOTE:</b> factory features are not used for XML Serializer.
+     *
+     * @return A new instance of a XML Serializer.
+     * @throws XmlPullParserException if a parser cannot be created which satisfies the
+     * requested configuration.
+     * @hide
+     */
+
+    public XmlSerializer newSerializer() throws XmlPullParserException {
+        return getSerializerInstance();
+    }
+
+    /**
+     * Creates a new instance of a PullParserFactory that can be used
+     * to create XML pull parsers. The factory will always return instances
+     * of Android's built-in {@link XmlPullParser} and {@link XmlSerializer}.
+     * @hide
+     */
+    public static XmlPullParserFactory newInstance () throws XmlPullParserException {
+        return new XmlPullParserFactory();
+    }
+
+    /**
+     * Creates a factory that always returns instances of Android's built-in
+     * {@link XmlPullParser} and {@link XmlSerializer} implementation. This
+     * <b>does not</b> support factories capable of creating arbitrary parser
+     * and serializer implementations. Both arguments to this method are unused.
+     * @hide
+     */
+    public static XmlPullParserFactory newInstance (String unused, Class unused2)
+        throws XmlPullParserException {
+        return newInstance();
+    }
+}
diff --git a/keystore/java/android/security/keystore2/XmlSerializer.java b/keystore/java/android/security/keystore2/XmlSerializer.java
new file mode 100644
index 000000000000..896e00bbb181
--- /dev/null
+++ b/keystore/java/android/security/keystore2/XmlSerializer.java
@@ -0,0 +1,329 @@
+package android.security.keystore2;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.Writer;
+
+/**
+ * Define an interface to serialization of XML Infoset.
+ * This interface abstracts away if serialized XML is XML 1.0 compatible text or
+ * other formats of XML 1.0 serializations (such as binary XML for example with WBXML).
+ *
+ * <p><b>PLEASE NOTE:</b> This interface will be part of XmlPull 1.2 API.
+ * It is included as basis for discussion. It may change in any way.
+ *
+ * <p>Exceptions that may be thrown are: IOException or runtime exception
+ * (more runtime exceptions can be thrown but are not declared and as such
+ * have no semantics defined for this interface):
+ * <ul>
+ * <li><em>IllegalArgumentException</em> - for almost all methods to signal that
+ *     argument is illegal
+ * <li><em>IllegalStateException</em> - to signal that call has good arguments but
+ *     is not expected here (violation of contract) and for features/properties
+ *    when requesting setting unimplemented feature/property
+ *    (UnsupportedOperationException would be better but it is not in MIDP)
+ *  </ul>
+ *
+ * <p><b>NOTE:</b> writing  CDSECT, ENTITY_REF, IGNORABLE_WHITESPACE,
+ *  PROCESSING_INSTRUCTION, COMMENT, and DOCDECL in some implementations
+ * may not be supported (for example when serializing to WBXML).
+ * In such case IllegalStateException will be thrown and it is recommended
+ * to use an optional feature to signal that implementation is not
+ * supporting this kind of output.
+ */
+
+/**
+ * BLabl
+ * @hide
+ */
+public interface XmlSerializer {
+
+    /**
+     * Set feature identified by name (recommended to be URI for uniqueness).
+     * Some well known optional features are defined in
+     * <a href="http://www.xmlpull.org/v1/doc/features.html">
+     * http://www.xmlpull.org/v1/doc/features.html</a>.
+     *
+     * If feature is not recognized or can not be set
+     * then IllegalStateException MUST be thrown.
+     *
+     * @exception IllegalStateException If the feature is not supported or can not be set
+     */
+    void setFeature(String name,
+                           boolean state)
+        throws IllegalArgumentException, IllegalStateException;
+
+
+    /**
+     * Return the current value of the feature with given name.
+     * <p><strong>NOTE:</strong> unknown properties are <strong>always</strong> returned as null
+     *
+     * @param name The name of feature to be retrieved.
+     * @return The value of named feature.
+     * @exception IllegalArgumentException if feature string is null
+     */
+    boolean getFeature(String name);
+
+
+    /**
+     * Set the value of a property.
+     * (the property name is recommended to be URI for uniqueness).
+     * Some well known optional properties are defined in
+     * <a href="http://www.xmlpull.org/v1/doc/properties.html">
+     * http://www.xmlpull.org/v1/doc/properties.html</a>.
+     *
+     * If property is not recognized or can not be set
+     * then IllegalStateException MUST be thrown.
+     *
+     * @exception IllegalStateException if the property is not supported or can not be set
+     */
+    void setProperty(String name,
+                            Object value)
+        throws IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Look up the value of a property.
+     *
+     * The property name is any fully-qualified URI. I
+     * <p><strong>NOTE:</strong> unknown properties are <string>always</strong> returned as null
+     *
+     * @param name The name of property to be retrieved.
+     * @return The value of named property.
+     */
+    Object getProperty(String name);
+
+    /**
+     * Set to use binary output stream with given encoding.
+     */
+    void setOutput (OutputStream os, String encoding)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Set the output to the given writer.
+     * <p><b>WARNING</b> no information about encoding is available!
+     */
+    void setOutput (Writer writer)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Write &lt;&#63;xml declaration with encoding (if encoding not null)
+     * and standalone flag (if standalone not null)
+     * This method can only be called just after setOutput.
+     */
+    void startDocument (String encoding, Boolean standalone)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Finish writing. All unclosed start tags will be closed and output
+     * will be flushed. After calling this method no more output can be
+     * serialized until next call to setOutput()
+     */
+    void endDocument ()
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Binds the given prefix to the given namespace.
+     * This call is valid for the next element including child elements.
+     * The prefix and namespace MUST be always declared even if prefix
+     * is not used in element (startTag() or attribute()) - for XML 1.0
+     * it must result in declaring <code>xmlns:prefix='namespace'</code>
+     * (or <code>xmlns:prefix="namespace"</code> depending what character is used
+     * to quote attribute value).
+     *
+     * <p><b>NOTE:</b> this method MUST be called directly before startTag()
+     *   and if anything but startTag() or setPrefix() is called next there will be exception.
+     * <p><b>NOTE:</b> prefixes "xml" and "xmlns" are already bound
+     *   and can not be redefined see:
+     * <a href="http://www.w3.org/XML/xml-names-19990114-errata#NE05">Namespaces in XML Errata</a>.
+     * <p><b>NOTE:</b> to set default namespace use as prefix empty string.
+     *
+     * @param prefix must be not null (or IllegalArgumentException is thrown)
+     * @param namespace must be not null
+     */
+    void setPrefix (String prefix, String namespace)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Return namespace that corresponds to given prefix
+     * If there is no prefix bound to this namespace return null
+     * but if generatePrefix is false then return generated prefix.
+     *
+     * <p><b>NOTE:</b> if the prefix is empty string "" and default namespace is bound
+     * to this prefix then empty string ("") is returned.
+     *
+     * <p><b>NOTE:</b> prefixes "xml" and "xmlns" are already bound
+     *   will have values as defined
+     * <a href="http://www.w3.org/TR/REC-xml-names/">Namespaces in XML specification</a>
+     */
+    String getPrefix (String namespace, boolean generatePrefix)
+        throws IllegalArgumentException;
+
+    /**
+     * Returns the current depth of the element.
+     * Outside the root element, the depth is 0. The
+     * depth is incremented by 1 when startTag() is called.
+     * The depth is decremented after the call to endTag()
+     * event was observed.
+     *
+     * <pre>
+     * &lt;!-- outside --&gt;     0
+     * &lt;root&gt;               1
+     *   sometext                 1
+     *     &lt;foobar&gt;         2
+     *     &lt;/foobar&gt;        2
+     * &lt;/root&gt;              1
+     * &lt;!-- outside --&gt;     0
+     * </pre>
+     */
+    int getDepth();
+
+    /**
+     * Returns the namespace URI of the current element as set by startTag().
+     *
+     * <p><b>NOTE:</b> that means in particular that: <ul>
+     * <li>if there was startTag("", ...) then getNamespace() returns ""
+     * <li>if there was startTag(null, ...) then getNamespace() returns null
+     * </ul>
+     *
+     * @return namespace set by startTag() that is currently in scope
+     */
+    String getNamespace ();
+
+    /**
+     * Returns the name of the current element as set by startTag().
+     * It can only be null before first call to startTag()
+     * or when last endTag() is called to close first startTag().
+     *
+     * @return namespace set by startTag() that is currently in scope
+     */
+    String getName();
+
+    /**
+     * Writes a start tag with the given namespace and name.
+     * If there is no prefix defined for the given namespace,
+     * a prefix will be defined automatically.
+     * The explicit prefixes for namespaces can be established by calling setPrefix()
+     * immediately before this method.
+     * If namespace is null no namespace prefix is printed but just name.
+     * If namespace is empty string then serializer will make sure that
+     * default empty namespace is declared (in XML 1.0 xmlns='')
+     * or throw IllegalStateException if default namespace is already bound
+     * to non-empty string.
+     */
+    XmlSerializer startTag (String namespace, String name)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Write an attribute. Calls to attribute() MUST follow a call to
+     * startTag() immediately. If there is no prefix defined for the
+     * given namespace, a prefix will be defined automatically.
+     * If namespace is null or empty string
+     * no namespace prefix is printed but just name.
+     */
+    XmlSerializer attribute (String namespace, String name, String value)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Write end tag. Repetition of namespace and name is just for avoiding errors.
+     * <p><b>Background:</b> in kXML endTag had no arguments, and non matching tags were
+     *  very difficult to find...
+     * If namespace is null no namespace prefix is printed but just name.
+     * If namespace is empty string then serializer will make sure that
+     * default empty namespace is declared (in XML 1.0 xmlns='').
+     */
+    XmlSerializer endTag (String namespace, String name)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+
+    //    /**
+    //     * Writes a start tag with the given namespace and name.
+    //     * <br />If there is no prefix defined (prefix == null) for the given namespace,
+    //     * a prefix will be defined automatically.
+    //     * <br />If explicit prefixes is passed (prefix != null) then it will be used
+    //      *and namespace declared if not already declared or
+    //     * throw IllegalStateException the same prefix was already set on this
+    //     * element (setPrefix()) and was bound to different namespace.
+    //     * <br />If namespace is null then prefix must be null too or IllegalStateException is thrown.
+    //     * <br />If namespace is null then no namespace prefix is printed but just name.
+    //     * <br />If namespace is empty string then serializer will make sure that
+    //     * default empty namespace is declared (in XML 1.0 xmlns='')
+    //     * or throw IllegalStateException if default namespace is already bound
+    //     * to non-empty string.
+    //     */
+    //    XmlSerializer startTag (String prefix, String namespace, String name)
+    //        throws IOException, IllegalArgumentException, IllegalStateException;
+    //
+    //    /**
+    //     * Write an attribute. Calls to attribute() MUST follow a call to
+    //     * startTag() immediately.
+    //     * <br />If there is no prefix defined (prefix == null) for the given namespace,
+    //     * a prefix will be defined automatically.
+    //     * <br />If explicit prefixes is passed (prefix != null) then it will be used
+    //     * and namespace declared if not already declared or
+    //     * throw IllegalStateException the same prefix was already set on this
+    //     * element (setPrefix()) and was bound to different namespace.
+    //     * <br />If namespace is null then prefix must be null too or IllegalStateException is thrown.
+    //     * <br />If namespace is null then no namespace prefix is printed but just name.
+    //     * <br />If namespace is empty string then serializer will make sure that
+    //     * default empty namespace is declared (in XML 1.0 xmlns='')
+    //     * or throw IllegalStateException if default namespace is already bound
+    //     * to non-empty string.
+    //     */
+    //    XmlSerializer attribute (String prefix, String namespace, String name, String value)
+    //        throws IOException, IllegalArgumentException, IllegalStateException;
+    //
+    //    /**
+    //     * Write end tag. Repetition of namespace, prefix, and name is just for avoiding errors.
+    //     * <br />If namespace or name arguments are different from corresponding startTag call
+    //     * then IllegalArgumentException is thrown, if prefix argument is not null and is different
+    //     * from corresponding starTag then IllegalArgumentException is thrown.
+    //     * <br />If namespace is null then prefix must be null too or IllegalStateException is thrown.
+    //     * <br />If namespace is null then no namespace prefix is printed but just name.
+    //     * <br />If namespace is empty string then serializer will make sure that
+    //     * default empty namespace is declared (in XML 1.0 xmlns='').
+    //     * <p><b>Background:</b> in kXML endTag had no arguments, and non matching tags were
+    //     *  very difficult to find...</p>
+    //     */
+    // ALEK: This is really optional as prefix in end tag MUST correspond to start tag but good for error checking
+    //    XmlSerializer endTag (String prefix, String namespace, String name)
+    //        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Writes text, where special XML chars are escaped automatically
+     */
+    XmlSerializer text (String text)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Writes text, where special XML chars are escaped automatically
+     */
+    XmlSerializer text (char [] buf, int start, int len)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    void cdsect (String text)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+    void entityRef (String text)  throws IOException,
+        IllegalArgumentException, IllegalStateException;
+    void processingInstruction (String text)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+    void comment (String text)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+    void docdecl (String text)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+    void ignorableWhitespace (String text)
+        throws IOException, IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Write all pending output to the stream.
+     * If method startTag() or attribute() was called then start tag is closed (final &gt;)
+     * before flush() is called on underlying output stream.
+     *
+     * <p><b>NOTE:</b> if there is need to close start tag
+     * (so no more attribute() calls are allowed) but without flushing output
+     * call method text() with empty string (text("")).
+     *
+     */
+    void flush ()
+        throws IOException;
+
+}
-- 
2.34.1

